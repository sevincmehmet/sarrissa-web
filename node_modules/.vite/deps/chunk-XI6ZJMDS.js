import {
  createSelectorCreator,
  lruMemoize
} from "./chunk-Z4QLFZ6V.js";
import {
  useThemeProps
} from "./chunk-5IC5WGPV.js";
import {
  _extends,
  useEnhancedEffect_default
} from "./chunk-37AZGXLP.js";
import {
  require_with_selector
} from "./chunk-TCR4MTUW.js";
import {
  require_jsx_runtime
} from "./chunk-NJLIVH7H.js";
import {
  require_react
} from "./chunk-HUL2CLQT.js";
import {
  __toESM
} from "./chunk-EWTE5DHJ.js";

// node_modules/@mui/x-tree-view/esm/internals/zero-styled/index.js
function createUseThemeProps(name) {
  return useThemeProps;
}

// node_modules/@mui/x-tree-view/esm/internals/TreeViewProvider/TreeViewStyleContext.js
var React = __toESM(require_react(), 1);
var TreeViewStyleContext = React.createContext({
  classes: {},
  slots: {},
  slotProps: {}
});
if (true) {
  TreeViewStyleContext.displayName = "TreeViewStyleContext";
}
var useTreeViewStyleContext = () => {
  return React.useContext(TreeViewStyleContext);
};

// node_modules/@mui/x-tree-view/esm/internals/TreeViewProvider/TreeViewProvider.js
var React3 = __toESM(require_react(), 1);

// node_modules/@mui/x-tree-view/esm/internals/TreeViewProvider/TreeViewContext.js
var React2 = __toESM(require_react(), 1);
var TreeViewContext = React2.createContext(null);
if (true) {
  TreeViewContext.displayName = "TreeViewContext";
}
var useTreeViewContext = () => {
  const context = React2.useContext(TreeViewContext);
  if (context == null) {
    throw new Error(["MUI X: Could not find the Tree View context.", "It looks like you rendered your component outside of a SimpleTreeView or RichTreeView parent component.", "This can also happen if you are bundling multiple versions of the Tree View."].join("\n"));
  }
  return context;
};

// node_modules/@mui/x-tree-view/esm/internals/TreeViewProvider/TreeViewProvider.js
var import_jsx_runtime = __toESM(require_jsx_runtime(), 1);
var EMPTY_OBJECT = {};
function TreeViewProvider(props) {
  const {
    contextValue,
    classes = EMPTY_OBJECT,
    slots = EMPTY_OBJECT,
    slotProps = EMPTY_OBJECT,
    children
  } = props;
  const styleContextValue = React3.useMemo(() => ({
    classes,
    slots: {
      collapseIcon: slots.collapseIcon,
      expandIcon: slots.expandIcon,
      endIcon: slots.endIcon
    },
    slotProps: {
      collapseIcon: slotProps.collapseIcon,
      expandIcon: slotProps.expandIcon,
      endIcon: slotProps.endIcon
    }
  }), [classes, slots.collapseIcon, slots.expandIcon, slots.endIcon, slotProps.collapseIcon, slotProps.expandIcon, slotProps.endIcon]);
  return (0, import_jsx_runtime.jsx)(TreeViewContext.Provider, {
    value: contextValue,
    children: (0, import_jsx_runtime.jsx)(TreeViewStyleContext.Provider, {
      value: styleContextValue,
      children: contextValue.wrapRoot({
        children
      })
    })
  });
}

// node_modules/@mui/x-tree-view/esm/internals/hooks/useSelector.js
var import_with_selector = __toESM(require_with_selector(), 1);
var defaultCompare = Object.is;
var useSelector = (store, selector, args = void 0, equals = defaultCompare) => {
  const selectorWithArgs = (state) => selector(state, args);
  return (0, import_with_selector.useSyncExternalStoreWithSelector)(store.subscribe, store.getSnapshot, store.getSnapshot, selectorWithArgs, equals);
};

// node_modules/@mui/x-tree-view/esm/internals/utils/selectors.js
var reselectCreateSelector = createSelectorCreator({
  memoize: lruMemoize,
  memoizeOptions: {
    maxSize: 1,
    equalityCheck: Object.is
  }
});
var cache = /* @__PURE__ */ new WeakMap();
var createSelector = (...createSelectorArgs) => {
  const selector = (state, selectorArgs) => {
    const cacheKey = state.cacheKey;
    let cacheForCurrentTreeViewInstance = cache.get(cacheKey);
    if (!cacheForCurrentTreeViewInstance) {
      cacheForCurrentTreeViewInstance = /* @__PURE__ */ new Map();
      cache.set(cacheKey, cacheForCurrentTreeViewInstance);
    }
    const cachedSelector = cacheForCurrentTreeViewInstance.get(createSelectorArgs);
    if (cachedSelector) {
      return cachedSelector(state, selectorArgs);
    }
    const fn = reselectCreateSelector(...createSelectorArgs);
    cacheForCurrentTreeViewInstance.set(createSelectorArgs, fn);
    return fn(state, selectorArgs);
  };
  return selector;
};

// node_modules/@mui/x-tree-view/esm/internals/corePlugins/useTreeViewId/useTreeViewId.selectors.js
var selectorTreeViewIdState = (state) => state.id;
var selectorTreeViewId = createSelector(selectorTreeViewIdState, (idState) => idState.treeId);

// node_modules/@mui/x-tree-view/esm/internals/corePlugins/useTreeViewId/useTreeViewId.utils.js
var globalTreeViewDefaultId = 0;
var createTreeViewDefaultId = () => {
  globalTreeViewDefaultId += 1;
  return `mui-tree-view-${globalTreeViewDefaultId}`;
};
var generateTreeItemIdAttribute = ({
  id,
  treeId = "",
  itemId
}) => {
  if (id != null) {
    return id;
  }
  return `${treeId}-${itemId}`;
};

// node_modules/@mui/x-tree-view/esm/internals/TreeViewItemDepthContext/TreeViewItemDepthContext.js
var React4 = __toESM(require_react(), 1);
var TreeViewItemDepthContext = React4.createContext(() => -1);
if (true) {
  TreeViewItemDepthContext.displayName = "TreeViewItemDepthContext";
}

// node_modules/@mui/x-tree-view/esm/internals/plugins/useTreeViewItems/useTreeViewItems.utils.js
var TREE_VIEW_ROOT_PARENT_ID = "__TREE_VIEW_ROOT_PARENT_ID__";
var buildSiblingIndexes = (siblings) => {
  const siblingsIndexLookup = {};
  siblings.forEach((childId, index) => {
    siblingsIndexLookup[childId] = index;
  });
  return siblingsIndexLookup;
};
var isItemDisabled = (itemMetaLookup, itemId) => {
  if (itemId == null) {
    return false;
  }
  let itemMeta = itemMetaLookup[itemId];
  if (!itemMeta) {
    return false;
  }
  if (itemMeta.disabled) {
    return true;
  }
  while (itemMeta.parentId != null) {
    itemMeta = itemMetaLookup[itemMeta.parentId];
    if (!itemMeta) {
      return false;
    }
    if (itemMeta.disabled) {
      return true;
    }
  }
  return false;
};

// node_modules/@mui/x-tree-view/esm/internals/plugins/useTreeViewItems/useTreeViewItems.selectors.js
var selectorTreeViewItemsState = (state) => state.items;
var selectorIsTreeViewLoading = createSelector(selectorTreeViewItemsState, (items) => items.loading);
var selectorGetTreeViewError = createSelector(selectorTreeViewItemsState, (items) => items.error);
var selectorItemMetaLookup = createSelector(selectorTreeViewItemsState, (items) => items.itemMetaLookup);
var EMPTY_CHILDREN = [];
var selectorItemOrderedChildrenIds = createSelector([selectorTreeViewItemsState, (_, itemId) => itemId], (itemsState, itemId) => itemsState.itemOrderedChildrenIdsLookup[itemId ?? TREE_VIEW_ROOT_PARENT_ID] ?? EMPTY_CHILDREN);
var selectorItemModel = createSelector([selectorTreeViewItemsState, (_, itemId) => itemId], (itemsState, itemId) => itemsState.itemModelLookup[itemId]);
var selectorItemMeta = createSelector([selectorItemMetaLookup, (_, itemId) => itemId], (itemMetaLookup, itemId) => itemMetaLookup[itemId ?? TREE_VIEW_ROOT_PARENT_ID] ?? null);
var selectorIsItemDisabled = createSelector([selectorItemMetaLookup, (_, itemId) => itemId], isItemDisabled);
var selectorItemIndex = createSelector([selectorTreeViewItemsState, selectorItemMeta], (itemsState, itemMeta) => {
  if (itemMeta == null) {
    return -1;
  }
  const parentIndexes = itemsState.itemChildrenIndexesLookup[itemMeta.parentId ?? TREE_VIEW_ROOT_PARENT_ID];
  return parentIndexes[itemMeta.id];
});
var selectorItemParentId = createSelector([selectorItemMeta], (itemMeta) => (itemMeta == null ? void 0 : itemMeta.parentId) ?? null);
var selectorItemDepth = createSelector([selectorItemMeta], (itemMeta) => (itemMeta == null ? void 0 : itemMeta.depth) ?? 0);
var selectorDisabledItemFocusable = createSelector([selectorTreeViewItemsState], (itemsState) => itemsState.disabledItemsFocusable);
var selectorCanItemBeFocused = createSelector([selectorDisabledItemFocusable, selectorIsItemDisabled], (disabledItemsFocusable, isDisabled) => {
  if (disabledItemsFocusable) {
    return true;
  }
  return !isDisabled;
});

// node_modules/@mui/x-tree-view/esm/internals/plugins/useTreeViewExpansion/useTreeViewExpansion.selectors.js
var selectorExpansion = (state) => state.expansion;
var selectorExpandedItems = createSelector([selectorExpansion], (expansionState) => expansionState.expandedItems);
var selectorExpandedItemsMap = createSelector([selectorExpandedItems], (expandedItems) => {
  const expandedItemsMap = /* @__PURE__ */ new Map();
  expandedItems.forEach((id) => {
    expandedItemsMap.set(id, true);
  });
  return expandedItemsMap;
});
var selectorIsItemExpanded = createSelector([selectorExpandedItemsMap, (_, itemId) => itemId], (expandedItemsMap, itemId) => expandedItemsMap.has(itemId));
var selectorIsItemExpandable = createSelector([selectorItemMeta], (itemMeta) => (itemMeta == null ? void 0 : itemMeta.expandable) ?? false);
var selectorItemExpansionTrigger = createSelector([selectorExpansion], (expansionState) => expansionState.expansionTrigger);

// node_modules/@mui/x-tree-view/esm/internals/utils/tree.js
var getLastNavigableItemInArray = (state, items) => {
  let itemIndex = items.length - 1;
  while (itemIndex >= 0 && !selectorCanItemBeFocused(state, items[itemIndex])) {
    itemIndex -= 1;
  }
  if (itemIndex === -1) {
    return void 0;
  }
  return items[itemIndex];
};
var getPreviousNavigableItem = (state, itemId) => {
  const itemMeta = selectorItemMeta(state, itemId);
  if (!itemMeta) {
    return null;
  }
  const siblings = selectorItemOrderedChildrenIds(state, itemMeta.parentId);
  const itemIndex = selectorItemIndex(state, itemId);
  if (itemIndex === 0) {
    return itemMeta.parentId;
  }
  let previousNavigableSiblingIndex = itemIndex - 1;
  while (!selectorCanItemBeFocused(state, siblings[previousNavigableSiblingIndex]) && previousNavigableSiblingIndex >= 0) {
    previousNavigableSiblingIndex -= 1;
  }
  if (previousNavigableSiblingIndex === -1) {
    if (itemMeta.parentId == null) {
      return null;
    }
    return getPreviousNavigableItem(state, itemMeta.parentId);
  }
  let currentItemId = siblings[previousNavigableSiblingIndex];
  let lastNavigableChild = getLastNavigableItemInArray(state, selectorItemOrderedChildrenIds(state, currentItemId));
  while (selectorIsItemExpanded(state, currentItemId) && lastNavigableChild != null) {
    currentItemId = lastNavigableChild;
    lastNavigableChild = getLastNavigableItemInArray(state, selectorItemOrderedChildrenIds(state, currentItemId));
  }
  return currentItemId;
};
var getNextNavigableItem = (state, itemId) => {
  if (selectorIsItemExpanded(state, itemId)) {
    const firstNavigableChild = selectorItemOrderedChildrenIds(state, itemId).find((childId) => selectorCanItemBeFocused(state, childId));
    if (firstNavigableChild != null) {
      return firstNavigableChild;
    }
  }
  let itemMeta = selectorItemMeta(state, itemId);
  while (itemMeta != null) {
    const siblings = selectorItemOrderedChildrenIds(state, itemMeta.parentId);
    const currentItemIndex = selectorItemIndex(state, itemMeta.id);
    if (currentItemIndex < siblings.length - 1) {
      let nextItemIndex = currentItemIndex + 1;
      while (!selectorCanItemBeFocused(state, siblings[nextItemIndex]) && nextItemIndex < siblings.length - 1) {
        nextItemIndex += 1;
      }
      if (selectorCanItemBeFocused(state, siblings[nextItemIndex])) {
        return siblings[nextItemIndex];
      }
    }
    itemMeta = selectorItemMeta(state, itemMeta.parentId);
  }
  return null;
};
var getLastNavigableItem = (state) => {
  let itemId = null;
  while (itemId == null || selectorIsItemExpanded(state, itemId)) {
    const children = selectorItemOrderedChildrenIds(state, itemId);
    const lastNavigableChild = getLastNavigableItemInArray(state, children);
    if (lastNavigableChild == null) {
      return itemId;
    }
    itemId = lastNavigableChild;
  }
  return itemId;
};
var getFirstNavigableItem = (state) => selectorItemOrderedChildrenIds(state, null).find((itemId) => selectorCanItemBeFocused(state, itemId));
var findOrderInTremauxTree = (state, itemAId, itemBId) => {
  if (itemAId === itemBId) {
    return [itemAId, itemBId];
  }
  const itemMetaA = selectorItemMeta(state, itemAId);
  const itemMetaB = selectorItemMeta(state, itemBId);
  if (!itemMetaA || !itemMetaB) {
    return [itemAId, itemBId];
  }
  if (itemMetaA.parentId === itemMetaB.id || itemMetaB.parentId === itemMetaA.id) {
    return itemMetaB.parentId === itemMetaA.id ? [itemMetaA.id, itemMetaB.id] : [itemMetaB.id, itemMetaA.id];
  }
  const aFamily = [itemMetaA.id];
  const bFamily = [itemMetaB.id];
  let aAncestor = itemMetaA.parentId;
  let bAncestor = itemMetaB.parentId;
  let aAncestorIsCommon = bFamily.indexOf(aAncestor) !== -1;
  let bAncestorIsCommon = aFamily.indexOf(bAncestor) !== -1;
  let continueA = true;
  let continueB = true;
  while (!bAncestorIsCommon && !aAncestorIsCommon) {
    if (continueA) {
      aFamily.push(aAncestor);
      aAncestorIsCommon = bFamily.indexOf(aAncestor) !== -1;
      continueA = aAncestor !== null;
      if (!aAncestorIsCommon && continueA) {
        aAncestor = selectorItemParentId(state, aAncestor);
      }
    }
    if (continueB && !aAncestorIsCommon) {
      bFamily.push(bAncestor);
      bAncestorIsCommon = aFamily.indexOf(bAncestor) !== -1;
      continueB = bAncestor !== null;
      if (!bAncestorIsCommon && continueB) {
        bAncestor = selectorItemParentId(state, bAncestor);
      }
    }
  }
  const commonAncestor = aAncestorIsCommon ? aAncestor : bAncestor;
  const ancestorFamily = selectorItemOrderedChildrenIds(state, commonAncestor);
  const aSide = aFamily[aFamily.indexOf(commonAncestor) - 1];
  const bSide = bFamily[bFamily.indexOf(commonAncestor) - 1];
  return ancestorFamily.indexOf(aSide) < ancestorFamily.indexOf(bSide) ? [itemAId, itemBId] : [itemBId, itemAId];
};
var getNonDisabledItemsInRange = (state, itemAId, itemBId) => {
  const getNextItem = (itemId) => {
    if (selectorIsItemExpandable(state, itemId) && selectorIsItemExpanded(state, itemId)) {
      return selectorItemOrderedChildrenIds(state, itemId)[0];
    }
    let itemMeta = selectorItemMeta(state, itemId);
    while (itemMeta != null) {
      const siblings = selectorItemOrderedChildrenIds(state, itemMeta.parentId);
      const currentItemIndex = selectorItemIndex(state, itemMeta.id);
      if (currentItemIndex < siblings.length - 1) {
        return siblings[currentItemIndex + 1];
      }
      itemMeta = itemMeta.parentId ? selectorItemMeta(state, itemMeta.parentId) : null;
    }
    throw new Error("Invalid range");
  };
  const [first, last] = findOrderInTremauxTree(state, itemAId, itemBId);
  const items = [first];
  let current = first;
  while (current !== last) {
    current = getNextItem(current);
    if (!selectorIsItemDisabled(state, current)) {
      items.push(current);
    }
  }
  return items;
};
var getAllNavigableItems = (state) => {
  let item = getFirstNavigableItem(state);
  const navigableItems = [];
  while (item != null) {
    navigableItems.push(item);
    item = getNextNavigableItem(state, item);
  }
  return navigableItems;
};
var isTargetInDescendants = (target, itemRoot) => {
  return itemRoot !== target.closest('*[role="treeitem"]');
};

// node_modules/@mui/x-tree-view/esm/internals/plugins/useTreeViewSelection/useTreeViewSelection.selectors.js
var selectorTreeViewSelectionState = (state) => state.selection;
var selectorSelectionModel = createSelector([selectorTreeViewSelectionState], (selectionState) => selectionState.selectedItems);
var selectorSelectionModelArray = createSelector([selectorSelectionModel], (selectedItems) => {
  if (Array.isArray(selectedItems)) {
    return selectedItems;
  }
  if (selectedItems != null) {
    return [selectedItems];
  }
  return [];
});
var selectorSelectionModelMap = createSelector([selectorSelectionModelArray], (selectedItems) => {
  const selectedItemsMap = /* @__PURE__ */ new Map();
  selectedItems.forEach((id) => {
    selectedItemsMap.set(id, true);
  });
  return selectedItemsMap;
});
var selectorIsItemSelected = createSelector([selectorSelectionModelMap, (_, itemId) => itemId], (selectedItemsMap, itemId) => selectedItemsMap.has(itemId));
var selectorIsMultiSelectEnabled = createSelector([selectorTreeViewSelectionState], (selectionState) => selectionState.isEnabled && selectionState.isMultiSelectEnabled);
var selectorIsSelectionEnabled = createSelector([selectorTreeViewSelectionState], (selectionState) => selectionState.isEnabled);
var selectorIsCheckboxSelectionEnabled = createSelector([selectorTreeViewSelectionState], (selectionState) => selectionState.isCheckboxSelectionEnabled);
var selectorIsItemSelectionEnabled = createSelector([selectorIsItemDisabled, selectorIsSelectionEnabled], (isItemDisabled2, isSelectionEnabled) => isSelectionEnabled && !isItemDisabled2);
var selectorSelectionPropagationRules = createSelector([selectorTreeViewSelectionState], (selectionState) => selectionState.selectionPropagation);

// node_modules/@mui/x-tree-view/esm/internals/plugins/useTreeViewFocus/useTreeViewFocus.selectors.js
var selectorTreeViewFocusState = (state) => state.focus;
var selectorDefaultFocusableItemId = createSelector([selectorSelectionModelArray, selectorExpandedItemsMap, selectorItemMetaLookup, selectorDisabledItemFocusable, (state) => selectorItemOrderedChildrenIds(state, null)], (selectedItems, expandedItemsMap, itemMetaLookup, disabledItemsFocusable, orderedRootItemIds) => {
  const firstSelectedItem = selectedItems.find((itemId) => {
    if (!disabledItemsFocusable && isItemDisabled(itemMetaLookup, itemId)) {
      return false;
    }
    const itemMeta = itemMetaLookup[itemId];
    return itemMeta && (itemMeta.parentId == null || expandedItemsMap.has(itemMeta.parentId));
  });
  if (firstSelectedItem != null) {
    return firstSelectedItem;
  }
  const firstNavigableItem = orderedRootItemIds.find((itemId) => disabledItemsFocusable || !isItemDisabled(itemMetaLookup, itemId));
  if (firstNavigableItem != null) {
    return firstNavigableItem;
  }
  return null;
});
var selectorIsItemTheDefaultFocusableItem = createSelector([selectorDefaultFocusableItemId, (_, itemId) => itemId], (defaultFocusableItemId, itemId) => defaultFocusableItemId === itemId);
var selectorFocusedItemId = createSelector(selectorTreeViewFocusState, (focus) => focus.focusedItemId);
var selectorIsItemFocused = createSelector([selectorFocusedItemId, (_, itemId) => itemId], (focusedItemId, itemId) => focusedItemId === itemId);

// node_modules/@mui/x-tree-view/esm/internals/plugins/useTreeViewLabel/useTreeViewLabel.itemPlugin.js
var React5 = __toESM(require_react(), 1);

// node_modules/@mui/x-tree-view/esm/internals/plugins/useTreeViewLabel/useTreeViewLabel.selectors.js
var selectorTreeViewLabelState = (state) => state.label;
var selectorIsItemEditable = createSelector([selectorTreeViewLabelState, (state, itemId) => selectorItemModel(state, itemId)], (labelState, itemModel) => {
  if (!itemModel || !labelState) {
    return false;
  }
  if (typeof labelState.isItemEditable === "boolean") {
    return labelState.isItemEditable;
  }
  return labelState.isItemEditable(itemModel);
});
var selectorIsItemBeingEdited = createSelector([selectorTreeViewLabelState, (_, itemId) => itemId], (labelState, itemId) => itemId ? (labelState == null ? void 0 : labelState.editedItemId) === itemId : false);
var selectorIsAnyItemBeingEdited = createSelector(selectorTreeViewLabelState, (labelState) => !!(labelState == null ? void 0 : labelState.editedItemId));

// node_modules/@mui/x-tree-view/esm/internals/plugins/useTreeViewLabel/useTreeViewLabel.itemPlugin.js
var useTreeViewLabelItemPlugin = ({
  props
}) => {
  const {
    store
  } = useTreeViewContext();
  const {
    label,
    itemId
  } = props;
  const [labelInputValue, setLabelInputValue] = React5.useState(label);
  const isItemEditable = useSelector(store, selectorIsItemEditable, itemId);
  const isItemBeingEdited = useSelector(store, selectorIsItemBeingEdited, itemId);
  React5.useEffect(() => {
    if (!isItemBeingEdited) {
      setLabelInputValue(label);
    }
  }, [isItemBeingEdited, label]);
  return {
    propsEnhancers: {
      label: () => ({
        editable: isItemEditable
      }),
      labelInput: ({
        externalEventHandlers,
        interactions
      }) => {
        if (!isItemEditable) {
          return {};
        }
        const handleKeydown = (event) => {
          var _a;
          (_a = externalEventHandlers.onKeyDown) == null ? void 0 : _a.call(externalEventHandlers, event);
          if (event.defaultMuiPrevented) {
            return;
          }
          const target = event.target;
          if (event.key === "Enter" && target.value) {
            interactions.handleSaveItemLabel(event, target.value);
          } else if (event.key === "Escape") {
            interactions.handleCancelItemLabelEditing(event);
          }
        };
        const handleBlur = (event) => {
          var _a;
          (_a = externalEventHandlers.onBlur) == null ? void 0 : _a.call(externalEventHandlers, event);
          if (event.defaultMuiPrevented) {
            return;
          }
          if (event.target.value) {
            interactions.handleSaveItemLabel(event, event.target.value);
          }
        };
        const handleInputChange = (event) => {
          var _a;
          (_a = externalEventHandlers.onChange) == null ? void 0 : _a.call(externalEventHandlers, event);
          setLabelInputValue(event.target.value);
        };
        return {
          value: labelInputValue ?? "",
          "data-element": "labelInput",
          onChange: handleInputChange,
          onKeyDown: handleKeydown,
          onBlur: handleBlur,
          autoFocus: true,
          type: "text"
        };
      }
    }
  };
};

// node_modules/@mui/x-tree-view/esm/internals/plugins/useTreeViewLabel/useTreeViewLabel.js
var useTreeViewLabel = ({
  store,
  params
}) => {
  const setEditedItemId = (editedItemId) => {
    store.update((prevState) => _extends({}, prevState, {
      label: _extends({}, prevState.label, {
        editedItemId
      })
    }));
  };
  const updateItemLabel = (itemId, label) => {
    if (!label) {
      throw new Error(["MUI X: The Tree View component requires all items to have a `label` property.", "The label of an item cannot be empty.", itemId].join("\n"));
    }
    store.update((prevState) => {
      const item = prevState.items.itemMetaLookup[itemId];
      if (item.label !== label) {
        return _extends({}, prevState, {
          items: _extends({}, prevState.items, {
            itemMetaLookup: _extends({}, prevState.items.itemMetaLookup, {
              [itemId]: _extends({}, item, {
                label
              })
            })
          })
        });
      }
      return prevState;
    });
    if (params.onItemLabelChange) {
      params.onItemLabelChange(itemId, label);
    }
  };
  useEnhancedEffect_default(() => {
    store.update((prevState) => _extends({}, prevState, {
      label: _extends({}, prevState.label, {
        isItemEditable: params.isItemEditable
      })
    }));
  }, [store, params.isItemEditable]);
  return {
    instance: {
      setEditedItemId,
      updateItemLabel
    },
    publicAPI: {
      updateItemLabel
    }
  };
};
useTreeViewLabel.itemPlugin = useTreeViewLabelItemPlugin;
useTreeViewLabel.applyDefaultValuesToParams = ({
  params
}) => _extends({}, params, {
  isItemEditable: params.isItemEditable ?? false
});
useTreeViewLabel.getInitialState = (params) => ({
  label: {
    isItemEditable: params.isItemEditable,
    editedItemId: null
  }
});
useTreeViewLabel.params = {
  onItemLabelChange: true,
  isItemEditable: true
};

// node_modules/@mui/x-tree-view/esm/internals/utils/plugins.js
var hasPlugin = (instance, plugin) => {
  const plugins = instance.getAvailablePlugins();
  return plugins.has(plugin);
};

// node_modules/@mui/x-tree-view/esm/internals/plugins/useTreeViewLazyLoading/useTreeViewLazyLoading.selectors.js
var selectorLazyLoading = (state) => state.lazyLoading;
var selectorLazyLoadingOptional = (state) => state.lazyLoading;
var selectorDataSourceState = createSelector([selectorLazyLoading], (lazyLoading) => lazyLoading.dataSource);
var selectorIsLazyLoadingEnabled = createSelector([selectorLazyLoadingOptional], (lazyLoading) => !!(lazyLoading == null ? void 0 : lazyLoading.enabled));
var selectorIsItemLoading = createSelector([selectorDataSourceState, (_, itemId) => itemId], (dataSourceState, itemId) => dataSourceState.loading[itemId] || false);
var selectorGetTreeItemError = createSelector([selectorDataSourceState, (_, itemId) => itemId], (dataSourceState, itemId) => dataSourceState.errors[itemId] || null);

// node_modules/@mui/x-tree-view/esm/hooks/useTreeItemUtils/useTreeItemUtils.js
var itemHasChildren = (reactChildren) => {
  if (Array.isArray(reactChildren)) {
    return reactChildren.length > 0 && reactChildren.some(itemHasChildren);
  }
  return Boolean(reactChildren);
};
var useTreeItemUtils = ({
  itemId,
  children
}) => {
  const {
    instance,
    store,
    publicAPI
  } = useTreeViewContext();
  const isItemExpandable = useSelector(store, selectorIsItemExpandable, itemId);
  const isLazyLoadingEnabled = useSelector(store, selectorIsLazyLoadingEnabled);
  const isMultiSelectEnabled = useSelector(store, selectorIsMultiSelectEnabled);
  const loading = useSelector(store, (state) => isLazyLoadingEnabled ? selectorIsItemLoading(state, itemId) : false);
  const error = useSelector(store, (state) => isLazyLoadingEnabled ? Boolean(selectorGetTreeItemError(state, itemId)) : false);
  const isExpandable = itemHasChildren(children) || isItemExpandable;
  const isExpanded = useSelector(store, selectorIsItemExpanded, itemId);
  const isFocused = useSelector(store, selectorIsItemFocused, itemId);
  const isSelected = useSelector(store, selectorIsItemSelected, itemId);
  const isDisabled = useSelector(store, selectorIsItemDisabled, itemId);
  const isEditing = useSelector(store, selectorIsItemBeingEdited, itemId);
  const isEditable = useSelector(store, selectorIsItemEditable, itemId);
  const status = {
    expandable: isExpandable,
    expanded: isExpanded,
    focused: isFocused,
    selected: isSelected,
    disabled: isDisabled,
    editing: isEditing,
    editable: isEditable,
    loading,
    error
  };
  const handleExpansion = (event) => {
    if (status.disabled) {
      return;
    }
    if (!status.focused) {
      instance.focusItem(event, itemId);
    }
    const multiple = isMultiSelectEnabled && (event.shiftKey || event.ctrlKey || event.metaKey);
    if (status.expandable && !(multiple && selectorIsItemExpanded(store.value, itemId))) {
      instance.setItemExpansion({
        event,
        itemId
      });
    }
  };
  const handleSelection = (event) => {
    if (status.disabled) {
      return;
    }
    if (!status.focused && !status.editing) {
      instance.focusItem(event, itemId);
    }
    const multiple = isMultiSelectEnabled && (event.shiftKey || event.ctrlKey || event.metaKey);
    if (multiple) {
      if (event.shiftKey) {
        instance.expandSelectionRange(event, itemId);
      } else {
        instance.setItemSelection({
          event,
          itemId,
          keepExistingSelection: true
        });
      }
    } else {
      instance.setItemSelection({
        event,
        itemId,
        shouldBeSelected: true
      });
    }
  };
  const handleCheckboxSelection = (event) => {
    const hasShift = event.nativeEvent.shiftKey;
    if (isMultiSelectEnabled && hasShift) {
      instance.expandSelectionRange(event, itemId);
    } else {
      instance.setItemSelection({
        event,
        itemId,
        keepExistingSelection: isMultiSelectEnabled,
        shouldBeSelected: event.target.checked
      });
    }
  };
  const toggleItemEditing = () => {
    if (!hasPlugin(instance, useTreeViewLabel)) {
      return;
    }
    if (isEditable) {
      if (isEditing) {
        instance.setEditedItemId(null);
      } else {
        instance.setEditedItemId(itemId);
      }
    }
  };
  const handleSaveItemLabel = (event, newLabel) => {
    if (!hasPlugin(instance, useTreeViewLabel)) {
      return;
    }
    if (selectorIsItemBeingEdited(store.value, itemId)) {
      instance.updateItemLabel(itemId, newLabel);
      toggleItemEditing();
      instance.focusItem(event, itemId);
    }
  };
  const handleCancelItemLabelEditing = (event) => {
    if (!hasPlugin(instance, useTreeViewLabel)) {
      return;
    }
    if (selectorIsItemBeingEdited(store.value, itemId)) {
      toggleItemEditing();
      instance.focusItem(event, itemId);
    }
  };
  const interactions = {
    handleExpansion,
    handleSelection,
    handleCheckboxSelection,
    toggleItemEditing,
    handleSaveItemLabel,
    handleCancelItemLabelEditing
  };
  return {
    interactions,
    status,
    publicAPI
  };
};

export {
  createUseThemeProps,
  useSelector,
  selectorTreeViewId,
  createTreeViewDefaultId,
  generateTreeItemIdAttribute,
  useTreeViewContext,
  useTreeViewStyleContext,
  TreeViewProvider,
  TREE_VIEW_ROOT_PARENT_ID,
  buildSiblingIndexes,
  TreeViewItemDepthContext,
  selectorItemMetaLookup,
  selectorItemOrderedChildrenIds,
  selectorItemModel,
  selectorItemMeta,
  selectorIsItemDisabled,
  selectorItemParentId,
  selectorItemDepth,
  selectorCanItemBeFocused,
  selectorExpandedItems,
  selectorIsItemExpanded,
  selectorIsItemExpandable,
  selectorItemExpansionTrigger,
  getPreviousNavigableItem,
  getNextNavigableItem,
  getLastNavigableItem,
  getFirstNavigableItem,
  findOrderInTremauxTree,
  getNonDisabledItemsInRange,
  getAllNavigableItems,
  isTargetInDescendants,
  selectorSelectionModel,
  selectorSelectionModelArray,
  selectorIsItemSelected,
  selectorIsMultiSelectEnabled,
  selectorIsSelectionEnabled,
  selectorIsCheckboxSelectionEnabled,
  selectorIsItemSelectionEnabled,
  selectorSelectionPropagationRules,
  selectorDefaultFocusableItemId,
  selectorIsItemTheDefaultFocusableItem,
  selectorFocusedItemId,
  hasPlugin,
  selectorIsItemEditable,
  selectorIsItemBeingEdited,
  useTreeViewLabel,
  itemHasChildren,
  useTreeItemUtils
};
//# sourceMappingURL=chunk-XI6ZJMDS.js.map
