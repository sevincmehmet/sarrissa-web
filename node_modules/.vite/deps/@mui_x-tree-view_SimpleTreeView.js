import {
  TREE_VIEW_ROOT_PARENT_ID,
  TreeViewItemDepthContext,
  TreeViewProvider,
  buildSiblingIndexes,
  createTreeViewDefaultId,
  createUseThemeProps,
  findOrderInTremauxTree,
  generateTreeItemIdAttribute,
  getAllNavigableItems,
  getFirstNavigableItem,
  getLastNavigableItem,
  getNextNavigableItem,
  getNonDisabledItemsInRange,
  getPreviousNavigableItem,
  hasPlugin,
  isTargetInDescendants,
  itemHasChildren,
  selectorDefaultFocusableItemId,
  selectorExpandedItems,
  selectorFocusedItemId,
  selectorIsCheckboxSelectionEnabled,
  selectorIsItemBeingEdited,
  selectorIsItemDisabled,
  selectorIsItemEditable,
  selectorIsItemExpandable,
  selectorIsItemExpanded,
  selectorIsItemSelected,
  selectorIsItemSelectionEnabled,
  selectorIsMultiSelectEnabled,
  selectorIsSelectionEnabled,
  selectorItemDepth,
  selectorItemMeta,
  selectorItemMetaLookup,
  selectorItemModel,
  selectorItemOrderedChildrenIds,
  selectorItemParentId,
  selectorSelectionModel,
  selectorSelectionModelArray,
  selectorSelectionPropagationRules,
  selectorTreeViewId,
  useSelector,
  useTreeViewContext,
  useTreeViewLabel
} from "./chunk-XI6ZJMDS.js";
import "./chunk-Z4QLFZ6V.js";
import {
  useSlotProps_default
} from "./chunk-6YJLAUAN.js";
import "./chunk-3T5YECHC.js";
import {
  _objectWithoutPropertiesLoose,
  useEventCallback_default,
  useForkRef
} from "./chunk-KI7UIJCI.js";
import "./chunk-5IC5WGPV.js";
import {
  _extends,
  composeClasses,
  generateUtilityClass,
  generateUtilityClasses,
  require_prop_types,
  styled_default2 as styled_default,
  useEnhancedEffect_default,
  useRtl
} from "./chunk-37AZGXLP.js";
import "./chunk-TCR4MTUW.js";
import "./chunk-VEB3A3D5.js";
import "./chunk-4EKW6KRM.js";
import "./chunk-Y3YHNSAO.js";
import {
  require_jsx_runtime
} from "./chunk-NJLIVH7H.js";
import {
  require_react
} from "./chunk-HUL2CLQT.js";
import {
  __toESM
} from "./chunk-EWTE5DHJ.js";

// node_modules/@mui/x-tree-view/esm/SimpleTreeView/SimpleTreeView.js
var React13 = __toESM(require_react(), 1);
var import_prop_types2 = __toESM(require_prop_types(), 1);

// node_modules/@mui/x-internals/esm/warning/warning.js
var warnedOnceCache = /* @__PURE__ */ new Set();
function warnOnce(message, gravity = "warning") {
  if (false) {
    return;
  }
  const cleanMessage = Array.isArray(message) ? message.join("\n") : message;
  if (!warnedOnceCache.has(cleanMessage)) {
    warnedOnceCache.add(cleanMessage);
    if (gravity === "error") {
      console.error(cleanMessage);
    } else {
      console.warn(cleanMessage);
    }
  }
}

// node_modules/@mui/x-tree-view/esm/SimpleTreeView/simpleTreeViewClasses.js
function getSimpleTreeViewUtilityClass(slot) {
  return generateUtilityClass("MuiSimpleTreeView", slot);
}
var simpleTreeViewClasses = generateUtilityClasses("MuiSimpleTreeView", ["root", "item", "itemContent", "itemGroupTransition", "itemIconContainer", "itemLabel", "itemCheckbox"]);

// node_modules/@mui/x-tree-view/esm/internals/useTreeView/useTreeView.js
var React5 = __toESM(require_react(), 1);

// node_modules/@mui/x-tree-view/esm/internals/corePlugins/useTreeViewInstanceEvents/useTreeViewInstanceEvents.js
var React = __toESM(require_react(), 1);

// node_modules/@mui/x-internals/esm/EventManager/EventManager.js
var EventManager = class {
  constructor() {
    this.maxListeners = 20;
    this.warnOnce = false;
    this.events = {};
  }
  on(eventName, listener, options = {}) {
    let collection = this.events[eventName];
    if (!collection) {
      collection = {
        highPriority: /* @__PURE__ */ new Map(),
        regular: /* @__PURE__ */ new Map()
      };
      this.events[eventName] = collection;
    }
    if (options.isFirst) {
      collection.highPriority.set(listener, true);
    } else {
      collection.regular.set(listener, true);
    }
    if (true) {
      const collectionSize = collection.highPriority.size + collection.regular.size;
      if (collectionSize > this.maxListeners && !this.warnOnce) {
        this.warnOnce = true;
        console.warn([`Possible EventEmitter memory leak detected. ${collectionSize} ${eventName} listeners added.`].join("\n"));
      }
    }
  }
  removeListener(eventName, listener) {
    if (this.events[eventName]) {
      this.events[eventName].regular.delete(listener);
      this.events[eventName].highPriority.delete(listener);
    }
  }
  removeAllListeners() {
    this.events = {};
  }
  emit(eventName, ...args) {
    const collection = this.events[eventName];
    if (!collection) {
      return;
    }
    const highPriorityListeners = Array.from(collection.highPriority.keys());
    const regularListeners = Array.from(collection.regular.keys());
    for (let i = highPriorityListeners.length - 1; i >= 0; i -= 1) {
      const listener = highPriorityListeners[i];
      if (collection.highPriority.has(listener)) {
        listener.apply(this, args);
      }
    }
    for (let i = 0; i < regularListeners.length; i += 1) {
      const listener = regularListeners[i];
      if (collection.regular.has(listener)) {
        listener.apply(this, args);
      }
    }
  }
  once(eventName, listener) {
    const that = this;
    this.on(eventName, function oneTimeListener(...args) {
      that.removeListener(eventName, oneTimeListener);
      listener.apply(that, args);
    });
  }
};

// node_modules/@mui/x-tree-view/esm/internals/corePlugins/useTreeViewInstanceEvents/useTreeViewInstanceEvents.js
var isSyntheticEvent = (event) => {
  return event.isPropagationStopped !== void 0;
};
var useTreeViewInstanceEvents = () => {
  const [eventManager] = React.useState(() => new EventManager());
  const publishEvent = React.useCallback((...args) => {
    const [name, params, event = {}] = args;
    event.defaultMuiPrevented = false;
    if (isSyntheticEvent(event) && event.isPropagationStopped()) {
      return;
    }
    eventManager.emit(name, params, event);
  }, [eventManager]);
  const subscribeEvent = React.useCallback((event, handler) => {
    eventManager.on(event, handler);
    return () => {
      eventManager.removeListener(event, handler);
    };
  }, [eventManager]);
  return {
    instance: {
      $$publishEvent: publishEvent,
      $$subscribeEvent: subscribeEvent
    }
  };
};
useTreeViewInstanceEvents.params = {};

// node_modules/@mui/x-tree-view/esm/internals/corePlugins/useTreeViewOptionalPlugins/useTreeViewOptionalPlugins.js
var useTreeViewOptionalPlugins = ({
  plugins
}) => {
  const pluginSet = new Set(plugins);
  const getAvailablePlugins = () => pluginSet;
  return {
    instance: {
      getAvailablePlugins
    }
  };
};
useTreeViewOptionalPlugins.params = {};

// node_modules/@mui/x-tree-view/esm/internals/corePlugins/useTreeViewId/useTreeViewId.js
var React2 = __toESM(require_react(), 1);
var useTreeViewId = ({
  params,
  store
}) => {
  React2.useEffect(() => {
    store.update((prevState) => {
      if (params.id === prevState.id.providedTreeId && prevState.id.treeId !== void 0) {
        return prevState;
      }
      return _extends({}, prevState, {
        id: _extends({}, prevState.id, {
          treeId: params.id ?? createTreeViewDefaultId()
        })
      });
    });
  }, [store, params.id]);
  const treeId = useSelector(store, selectorTreeViewId);
  return {
    getRootProps: () => ({
      id: treeId
    })
  };
};
useTreeViewId.params = {
  id: true
};
useTreeViewId.getInitialState = ({
  id
}) => ({
  id: {
    treeId: void 0,
    providedTreeId: id
  }
});

// node_modules/@mui/x-tree-view/esm/internals/corePlugins/corePlugins.js
var TREE_VIEW_CORE_PLUGINS = [useTreeViewInstanceEvents, useTreeViewOptionalPlugins, useTreeViewId];

// node_modules/@mui/x-tree-view/esm/internals/useTreeView/useExtractPluginParamsFromProps.js
var React3 = __toESM(require_react(), 1);
var _excluded = ["apiRef"];
var useExtractPluginParamsFromProps = (_ref) => {
  let {
    props: {
      apiRef
    },
    plugins
  } = _ref, props = _objectWithoutPropertiesLoose(_ref.props, _excluded);
  const paramsLookup = React3.useMemo(() => {
    const tempParamsLookup = {};
    plugins.forEach((plugin) => {
      Object.assign(tempParamsLookup, plugin.params);
    });
    return tempParamsLookup;
  }, [plugins]);
  const {
    forwardedProps,
    pluginParams
  } = React3.useMemo(() => {
    const tempPluginParams = {};
    const tempForwardedProps = {};
    Object.keys(props).forEach((propName) => {
      const prop = props[propName];
      if (paramsLookup[propName]) {
        tempPluginParams[propName] = prop;
      } else {
        tempForwardedProps[propName] = prop;
      }
    });
    const pluginParamsWithDefaults = plugins.reduce((acc, plugin) => {
      if (plugin.applyDefaultValuesToParams) {
        return plugin.applyDefaultValuesToParams({
          params: acc
        });
      }
      return acc;
    }, tempPluginParams);
    return {
      forwardedProps: tempForwardedProps,
      pluginParams: pluginParamsWithDefaults
    };
  }, [plugins, props, paramsLookup]);
  return {
    forwardedProps,
    pluginParams,
    apiRef
  };
};

// node_modules/@mui/x-tree-view/esm/internals/useTreeView/useTreeViewBuildContext.js
var React4 = __toESM(require_react(), 1);
var useTreeViewBuildContext = (parameters) => {
  const {
    plugins,
    instance,
    publicAPI,
    store,
    rootRef
  } = parameters;
  const runItemPlugins = React4.useCallback((itemPluginProps) => {
    let finalRootRef = null;
    let finalContentRef = null;
    const pluginPropEnhancers = [];
    const pluginPropEnhancersNames = {};
    plugins.forEach((plugin) => {
      if (!plugin.itemPlugin) {
        return;
      }
      const itemPluginResponse = plugin.itemPlugin({
        props: itemPluginProps,
        rootRef: finalRootRef,
        contentRef: finalContentRef
      });
      if (itemPluginResponse == null ? void 0 : itemPluginResponse.rootRef) {
        finalRootRef = itemPluginResponse.rootRef;
      }
      if (itemPluginResponse == null ? void 0 : itemPluginResponse.contentRef) {
        finalContentRef = itemPluginResponse.contentRef;
      }
      if (itemPluginResponse == null ? void 0 : itemPluginResponse.propsEnhancers) {
        pluginPropEnhancers.push(itemPluginResponse.propsEnhancers);
        Object.keys(itemPluginResponse.propsEnhancers).forEach((propsEnhancerName) => {
          pluginPropEnhancersNames[propsEnhancerName] = true;
        });
      }
    });
    const resolvePropsEnhancer = (currentSlotName) => (currentSlotParams) => {
      const enhancedProps = {};
      pluginPropEnhancers.forEach((propsEnhancersForCurrentPlugin) => {
        const propsEnhancerForCurrentPluginAndSlot = propsEnhancersForCurrentPlugin[currentSlotName];
        if (propsEnhancerForCurrentPluginAndSlot != null) {
          Object.assign(enhancedProps, propsEnhancerForCurrentPluginAndSlot(currentSlotParams));
        }
      });
      return enhancedProps;
    };
    const propsEnhancers = Object.fromEntries(Object.keys(pluginPropEnhancersNames).map((propEnhancerName) => [propEnhancerName, resolvePropsEnhancer(propEnhancerName)]));
    return {
      contentRef: finalContentRef,
      rootRef: finalRootRef,
      propsEnhancers
    };
  }, [plugins]);
  const wrapItem = React4.useCallback(({
    itemId,
    children,
    idAttribute
  }) => {
    let finalChildren = children;
    for (let i = plugins.length - 1; i >= 0; i -= 1) {
      const plugin = plugins[i];
      if (plugin.wrapItem) {
        finalChildren = plugin.wrapItem({
          instance,
          itemId,
          children: finalChildren,
          idAttribute
        });
      }
    }
    return finalChildren;
  }, [plugins, instance]);
  const wrapRoot = React4.useCallback(({
    children
  }) => {
    let finalChildren = children;
    for (let i = plugins.length - 1; i >= 0; i -= 1) {
      const plugin = plugins[i];
      if (plugin.wrapRoot) {
        finalChildren = plugin.wrapRoot({
          children: finalChildren
        });
      }
    }
    return finalChildren;
  }, [plugins]);
  return React4.useMemo(() => ({
    runItemPlugins,
    wrapItem,
    wrapRoot,
    instance,
    publicAPI,
    store,
    rootRef
  }), [runItemPlugins, wrapItem, wrapRoot, instance, publicAPI, store, rootRef]);
};

// node_modules/@mui/x-tree-view/esm/internals/utils/TreeViewStore.js
var TreeViewStore = class {
  constructor(value) {
    this.value = void 0;
    this.listeners = void 0;
    this.subscribe = (fn) => {
      this.listeners.add(fn);
      return () => {
        this.listeners.delete(fn);
      };
    };
    this.getSnapshot = () => {
      return this.value;
    };
    this.update = (updater) => {
      const newState = updater(this.value);
      if (newState !== this.value) {
        this.value = newState;
        this.listeners.forEach((l) => l(newState));
      }
    };
    this.value = value;
    this.listeners = /* @__PURE__ */ new Set();
  }
};

// node_modules/@mui/x-tree-view/esm/internals/useTreeView/useTreeView.js
function initializeInputApiRef(inputApiRef) {
  if (inputApiRef.current == null) {
    inputApiRef.current = {};
  }
  return inputApiRef;
}
function useTreeViewApiInitialization(inputApiRef) {
  const fallbackPublicApiRef = React5.useRef({});
  if (inputApiRef) {
    return initializeInputApiRef(inputApiRef);
  }
  return fallbackPublicApiRef;
}
var globalId = 0;
var useTreeView = ({
  plugins: inPlugins,
  rootRef,
  props
}) => {
  const plugins = React5.useMemo(() => [...TREE_VIEW_CORE_PLUGINS, ...inPlugins], [inPlugins]);
  const {
    pluginParams,
    forwardedProps,
    apiRef
  } = useExtractPluginParamsFromProps({
    plugins,
    props
  });
  const instanceRef = React5.useRef({});
  const instance = instanceRef.current;
  const publicAPI = useTreeViewApiInitialization(apiRef);
  const innerRootRef = React5.useRef(null);
  const handleRootRef = useForkRef(innerRootRef, rootRef);
  const storeRef = React5.useRef(null);
  if (storeRef.current == null) {
    globalId += 1;
    const initialState = {
      cacheKey: {
        id: globalId
      }
    };
    plugins.forEach((plugin) => {
      if (plugin.getInitialState) {
        Object.assign(initialState, plugin.getInitialState(pluginParams));
      }
    });
    storeRef.current = new TreeViewStore(initialState);
  }
  const contextValue = useTreeViewBuildContext({
    plugins,
    instance,
    publicAPI: publicAPI.current,
    store: storeRef.current,
    rootRef: innerRootRef
  });
  const rootPropsGetters = [];
  const runPlugin = (plugin) => {
    const pluginResponse = plugin({
      instance,
      params: pluginParams,
      rootRef: innerRootRef,
      plugins,
      store: storeRef.current
    });
    if (pluginResponse.getRootProps) {
      rootPropsGetters.push(pluginResponse.getRootProps);
    }
    if (pluginResponse.publicAPI) {
      Object.assign(publicAPI.current, pluginResponse.publicAPI);
    }
    if (pluginResponse.instance) {
      Object.assign(instance, pluginResponse.instance);
    }
  };
  plugins.forEach(runPlugin);
  const getRootProps = (otherHandlers = {}) => {
    const rootProps = _extends({
      role: "tree"
    }, forwardedProps, otherHandlers, {
      ref: handleRootRef
    });
    rootPropsGetters.forEach((rootPropsGetter) => {
      Object.assign(rootProps, rootPropsGetter(otherHandlers));
    });
    return rootProps;
  };
  return {
    getRootProps,
    rootRef: handleRootRef,
    contextValue
  };
};

// node_modules/@mui/x-tree-view/esm/internals/plugins/useTreeViewItems/useTreeViewItems.js
var React6 = __toESM(require_react(), 1);

// node_modules/@mui/x-tree-view/esm/internals/utils/publishTreeViewEvent.js
var publishTreeViewEvent = (instance, eventName, params) => {
  instance.$$publishEvent(eventName, params);
};

// node_modules/@mui/x-tree-view/esm/internals/plugins/useTreeViewItems/useTreeViewItems.js
var import_jsx_runtime = __toESM(require_jsx_runtime(), 1);
var checkId = (id, item, itemMetaLookup) => {
  if (id == null) {
    throw new Error(["MUI X: The Tree View component requires all items to have a unique `id` property.", "Alternatively, you can use the `getItemId` prop to specify a custom id for each item.", "An item was provided without id in the `items` prop:", JSON.stringify(item)].join("\n"));
  }
  if (itemMetaLookup[id] != null) {
    throw new Error(["MUI X: The Tree View component requires all items to have a unique `id` property.", "Alternatively, you can use the `getItemId` prop to specify a custom id for each item.", `Two items were provided with the same id in the \`items\` prop: "${id}"`].join("\n"));
  }
};
var processItemsLookups = ({
  disabledItemsFocusable,
  items,
  isItemDisabled,
  getItemLabel,
  getItemId,
  initialDepth = 0,
  initialParentId = null,
  getChildrenCount,
  ignoreChildren = false
}) => {
  const itemMetaLookup = {};
  const itemModelLookup = {};
  const itemOrderedChildrenIdsLookup = {
    [TREE_VIEW_ROOT_PARENT_ID]: []
  };
  const processItem = (item, depth, parentId) => {
    var _a, _b;
    const id = getItemId ? getItemId(item) : item.id;
    checkId(id, item, itemMetaLookup);
    const label = getItemLabel ? getItemLabel(item) : item.label;
    if (label == null) {
      throw new Error(["MUI X: The Tree View component requires all items to have a `label` property.", "Alternatively, you can use the `getItemLabel` prop to specify a custom label for each item.", "An item was provided without label in the `items` prop:", JSON.stringify(item)].join("\n"));
    }
    itemMetaLookup[id] = {
      id,
      label,
      parentId,
      idAttribute: void 0,
      expandable: getChildrenCount ? getChildrenCount(item) > 0 : !!((_a = item.children) == null ? void 0 : _a.length),
      disabled: isItemDisabled ? isItemDisabled(item) : false,
      depth
    };
    itemModelLookup[id] = item;
    const parentIdWithDefault = parentId ?? TREE_VIEW_ROOT_PARENT_ID;
    if (!itemOrderedChildrenIdsLookup[parentIdWithDefault]) {
      itemOrderedChildrenIdsLookup[parentIdWithDefault] = [];
    }
    itemOrderedChildrenIdsLookup[parentIdWithDefault].push(id);
    if (!ignoreChildren) {
      (_b = item.children) == null ? void 0 : _b.forEach((child) => processItem(child, depth + 1, id));
    }
  };
  items == null ? void 0 : items.forEach((item) => processItem(item, initialDepth, initialParentId));
  const itemChildrenIndexesLookup = {};
  Object.keys(itemOrderedChildrenIdsLookup).forEach((parentId) => {
    itemChildrenIndexesLookup[parentId] = buildSiblingIndexes(itemOrderedChildrenIdsLookup[parentId]);
  });
  return {
    disabledItemsFocusable,
    itemMetaLookup,
    itemModelLookup,
    itemOrderedChildrenIdsLookup,
    itemChildrenIndexesLookup
  };
};
var useTreeViewItems = ({
  instance,
  params,
  store
}) => {
  const getItem = React6.useCallback((itemId) => selectorItemModel(store.value, itemId), [store]);
  const getParentId = React6.useCallback((itemId) => {
    const itemMeta = selectorItemMeta(store.value, itemId);
    return (itemMeta == null ? void 0 : itemMeta.parentId) || null;
  }, [store]);
  const setTreeViewLoading = useEventCallback_default((isLoading) => {
    store.update((prevState) => _extends({}, prevState, {
      items: _extends({}, prevState.items, {
        loading: isLoading
      })
    }));
  });
  const setTreeViewError = useEventCallback_default((error) => {
    store.update((prevState) => _extends({}, prevState, {
      items: _extends({}, prevState.items, {
        error
      })
    }));
  });
  const setIsItemDisabled = useEventCallback_default(({
    itemId,
    shouldBeDisabled
  }) => {
    store.update((prevState) => {
      if (!prevState.items.itemMetaLookup[itemId]) {
        return prevState;
      }
      const itemMetaLookup = _extends({}, prevState.items.itemMetaLookup);
      itemMetaLookup[itemId] = _extends({}, itemMetaLookup[itemId], {
        disabled: shouldBeDisabled ?? !itemMetaLookup[itemId].disabled
      });
      return _extends({}, prevState, {
        items: _extends({}, prevState.items, {
          itemMetaLookup
        })
      });
    });
  });
  const getItemTree = React6.useCallback(() => {
    const getItemFromItemId = (itemId) => {
      const item = selectorItemModel(store.value, itemId);
      const newChildren = selectorItemOrderedChildrenIds(store.value, itemId);
      if (newChildren.length > 0) {
        item.children = newChildren.map(getItemFromItemId);
      } else {
        delete item.children;
      }
      return item;
    };
    return selectorItemOrderedChildrenIds(store.value, null).map(getItemFromItemId);
  }, [store]);
  const getItemOrderedChildrenIds = React6.useCallback((itemId) => selectorItemOrderedChildrenIds(store.value, itemId), [store]);
  const getItemDOMElement = (itemId) => {
    const itemMeta = selectorItemMeta(store.value, itemId);
    if (itemMeta == null) {
      return null;
    }
    const idAttribute = generateTreeItemIdAttribute({
      treeId: selectorTreeViewId(store.value),
      itemId,
      id: itemMeta.idAttribute
    });
    return document.getElementById(idAttribute);
  };
  const areItemUpdatesPreventedRef = React6.useRef(false);
  const preventItemUpdates = React6.useCallback(() => {
    areItemUpdatesPreventedRef.current = true;
  }, []);
  const areItemUpdatesPrevented = React6.useCallback(() => areItemUpdatesPreventedRef.current, []);
  const addItems = ({
    items,
    parentId,
    depth,
    getChildrenCount
  }) => {
    if (items) {
      const newState = processItemsLookups({
        disabledItemsFocusable: params.disabledItemsFocusable,
        items,
        isItemDisabled: params.isItemDisabled,
        getItemId: params.getItemId,
        getItemLabel: params.getItemLabel,
        getChildrenCount,
        initialDepth: depth,
        initialParentId: parentId,
        ignoreChildren: true
      });
      store.update((prevState) => {
        let newItems;
        if (parentId) {
          newItems = {
            itemModelLookup: _extends({}, prevState.items.itemModelLookup, newState.itemModelLookup),
            itemMetaLookup: _extends({}, prevState.items.itemMetaLookup, newState.itemMetaLookup),
            itemOrderedChildrenIdsLookup: _extends({}, newState.itemOrderedChildrenIdsLookup, prevState.items.itemOrderedChildrenIdsLookup),
            itemChildrenIndexesLookup: _extends({}, newState.itemChildrenIndexesLookup, prevState.items.itemChildrenIndexesLookup)
          };
        } else {
          newItems = {
            itemModelLookup: newState.itemModelLookup,
            itemMetaLookup: newState.itemMetaLookup,
            itemOrderedChildrenIdsLookup: newState.itemOrderedChildrenIdsLookup,
            itemChildrenIndexesLookup: newState.itemChildrenIndexesLookup
          };
        }
        Object.values(prevState.items.itemMetaLookup).forEach((item) => {
          if (!newState.itemMetaLookup[item.id]) {
            publishTreeViewEvent(instance, "removeItem", {
              id: item.id
            });
          }
        });
        return _extends({}, prevState, {
          items: _extends({}, prevState.items, newItems)
        });
      });
    }
  };
  const removeChildren = (parentId) => {
    store.update((prevState) => {
      if (!parentId) {
        return _extends({}, prevState, {
          items: _extends({}, prevState.items, {
            itemMetaLookup: {},
            itemOrderedChildrenIdsLookup: {},
            itemChildrenIndexesLookup: {}
          })
        });
      }
      const newMetaMap = Object.keys(prevState.items.itemMetaLookup).reduce((acc, key) => {
        const item = prevState.items.itemMetaLookup[key];
        if (item.parentId === parentId) {
          publishTreeViewEvent(instance, "removeItem", {
            id: item.id
          });
          return acc;
        }
        return _extends({}, acc, {
          [item.id]: item
        });
      }, {});
      const newItemOrderedChildrenIdsLookup = prevState.items.itemOrderedChildrenIdsLookup;
      const newItemChildrenIndexesLookup = prevState.items.itemChildrenIndexesLookup;
      delete newItemChildrenIndexesLookup[parentId];
      delete newItemOrderedChildrenIdsLookup[parentId];
      return _extends({}, prevState, {
        items: _extends({}, prevState.items, {
          itemMetaLookup: newMetaMap,
          itemOrderedChildrenIdsLookup: newItemOrderedChildrenIdsLookup,
          itemChildrenIndexesLookup: newItemChildrenIndexesLookup
        })
      });
    });
  };
  React6.useEffect(() => {
    if (instance.areItemUpdatesPrevented()) {
      return;
    }
    store.update((prevState) => {
      const newState = processItemsLookups({
        disabledItemsFocusable: params.disabledItemsFocusable,
        items: params.items,
        isItemDisabled: params.isItemDisabled,
        getItemId: params.getItemId,
        getItemLabel: params.getItemLabel
      });
      Object.values(prevState.items.itemMetaLookup).forEach((item) => {
        if (!newState.itemMetaLookup[item.id]) {
          publishTreeViewEvent(instance, "removeItem", {
            id: item.id
          });
        }
      });
      return _extends({}, prevState, {
        items: _extends({}, prevState.items, newState)
      });
    });
  }, [instance, store, params.items, params.disabledItemsFocusable, params.isItemDisabled, params.getItemId, params.getItemLabel]);
  const handleItemClick = useEventCallback_default((event, itemId) => {
    if (params.onItemClick) {
      params.onItemClick(event, itemId);
    }
  });
  return {
    getRootProps: () => ({
      style: {
        "--TreeView-itemChildrenIndentation": typeof params.itemChildrenIndentation === "number" ? `${params.itemChildrenIndentation}px` : params.itemChildrenIndentation
      }
    }),
    publicAPI: {
      getItem,
      getItemDOMElement,
      getItemTree,
      getItemOrderedChildrenIds,
      setIsItemDisabled,
      getParentId
    },
    instance: {
      getItemDOMElement,
      preventItemUpdates,
      areItemUpdatesPrevented,
      addItems,
      setTreeViewLoading,
      setTreeViewError,
      removeChildren,
      handleItemClick
    }
  };
};
useTreeViewItems.getInitialState = (params) => ({
  items: _extends({}, processItemsLookups({
    disabledItemsFocusable: params.disabledItemsFocusable,
    items: params.items,
    isItemDisabled: params.isItemDisabled,
    getItemId: params.getItemId,
    getItemLabel: params.getItemLabel
  }), {
    loading: false,
    error: null
  })
});
useTreeViewItems.applyDefaultValuesToParams = ({
  params
}) => _extends({}, params, {
  disabledItemsFocusable: params.disabledItemsFocusable ?? false,
  itemChildrenIndentation: params.itemChildrenIndentation ?? "12px"
});
useTreeViewItems.wrapRoot = ({
  children
}) => {
  return (0, import_jsx_runtime.jsx)(TreeViewItemDepthContext.Provider, {
    value: selectorItemDepth,
    children
  });
};
useTreeViewItems.params = {
  disabledItemsFocusable: true,
  items: true,
  isItemDisabled: true,
  getItemLabel: true,
  getItemId: true,
  onItemClick: true,
  itemChildrenIndentation: true
};

// node_modules/@mui/x-internals/esm/useAssertModelConsistency/useAssertModelConsistency.js
var React7 = __toESM(require_react(), 1);
function useAssertModelConsistencyOutsideOfProduction(parameters) {
  const {
    componentName,
    propName,
    controlled,
    defaultValue,
    warningPrefix = "MUI X"
  } = parameters;
  const [{
    initialDefaultValue,
    isControlled
  }] = React7.useState({
    initialDefaultValue: defaultValue,
    isControlled: controlled !== void 0
  });
  if (isControlled !== (controlled !== void 0)) {
    warnOnce([`${warningPrefix}: A component is changing the ${isControlled ? "" : "un"}controlled ${propName} state of ${componentName} to be ${isControlled ? "un" : ""}controlled.`, "Elements should not switch from uncontrolled to controlled (or vice versa).", `Decide between using a controlled or uncontrolled ${propName} element for the lifetime of the component.`, "The nature of the state is determined during the first render. It's considered controlled if the value is not `undefined`.", "More info: https://fb.me/react-controlled-components"], "error");
  }
  if (JSON.stringify(initialDefaultValue) !== JSON.stringify(defaultValue)) {
    warnOnce([`${warningPrefix}: A component is changing the default ${propName} state of an uncontrolled ${componentName} after being initialized. To suppress this warning opt to use a controlled ${componentName}.`], "error");
  }
}
var useAssertModelConsistency = false ? () => {
} : useAssertModelConsistencyOutsideOfProduction;

// node_modules/@mui/x-tree-view/esm/internals/plugins/useTreeViewExpansion/useTreeViewExpansion.utils.js
var getExpansionTrigger = ({
  isItemEditable,
  expansionTrigger
}) => {
  if (expansionTrigger) {
    return expansionTrigger;
  }
  if (isItemEditable) {
    return "iconContainer";
  }
  return "content";
};

// node_modules/@mui/x-tree-view/esm/internals/plugins/useTreeViewExpansion/useTreeViewExpansion.js
var useTreeViewExpansion = ({
  instance,
  store,
  params
}) => {
  useAssertModelConsistency({
    componentName: "Tree View",
    propName: "expandedItems",
    controlled: params.expandedItems,
    defaultValue: params.defaultExpandedItems
  });
  useEnhancedEffect_default(() => {
    store.update((prevState) => {
      const newExpansionTrigger = getExpansionTrigger({
        isItemEditable: params.isItemEditable,
        expansionTrigger: params.expansionTrigger
      });
      if (prevState.expansion.expansionTrigger === newExpansionTrigger) {
        return prevState;
      }
      return _extends({}, prevState, {
        expansion: _extends({}, prevState.expansion, {
          expansionTrigger: newExpansionTrigger
        })
      });
    });
  }, [store, params.isItemEditable, params.expansionTrigger]);
  const setExpandedItems = (event, value) => {
    var _a;
    if (params.expandedItems === void 0) {
      store.update((prevState) => _extends({}, prevState, {
        expansion: _extends({}, prevState.expansion, {
          expandedItems: value
        })
      }));
    }
    (_a = params.onExpandedItemsChange) == null ? void 0 : _a.call(params, event, value);
  };
  const applyItemExpansion = useEventCallback_default(({
    itemId,
    event,
    shouldBeExpanded
  }) => {
    const oldExpanded = selectorExpandedItems(store.value);
    let newExpanded;
    if (shouldBeExpanded) {
      newExpanded = [itemId].concat(oldExpanded);
    } else {
      newExpanded = oldExpanded.filter((id) => id !== itemId);
    }
    if (params.onItemExpansionToggle) {
      params.onItemExpansionToggle(event, itemId, shouldBeExpanded);
    }
    setExpandedItems(event, newExpanded);
  });
  const setItemExpansion = useEventCallback_default(({
    itemId,
    event = null,
    shouldBeExpanded
  }) => {
    const isExpandedBefore = selectorIsItemExpanded(store.value, itemId);
    const cleanShouldBeExpanded = shouldBeExpanded ?? !isExpandedBefore;
    if (isExpandedBefore === cleanShouldBeExpanded) {
      return;
    }
    const eventParameters = {
      isExpansionPrevented: false,
      shouldBeExpanded: cleanShouldBeExpanded,
      event,
      itemId
    };
    publishTreeViewEvent(instance, "beforeItemToggleExpansion", eventParameters);
    if (eventParameters.isExpansionPrevented) {
      return;
    }
    instance.applyItemExpansion({
      itemId,
      event,
      shouldBeExpanded: cleanShouldBeExpanded
    });
  });
  const expandAllSiblings = (event, itemId) => {
    const itemMeta = selectorItemMeta(store.value, itemId);
    if (itemMeta == null) {
      return;
    }
    const siblings = selectorItemOrderedChildrenIds(store.value, itemMeta.parentId);
    const diff = siblings.filter((child) => selectorIsItemExpandable(store.value, child) && !selectorIsItemExpanded(store.value, child));
    const newExpanded = selectorExpandedItems(store.value).concat(diff);
    if (diff.length > 0) {
      if (params.onItemExpansionToggle) {
        diff.forEach((newlyExpandedItemId) => {
          params.onItemExpansionToggle(event, newlyExpandedItemId, true);
        });
      }
      setExpandedItems(event, newExpanded);
    }
  };
  useEnhancedEffect_default(() => {
    const expandedItems = params.expandedItems;
    if (expandedItems !== void 0) {
      store.update((prevState) => _extends({}, prevState, {
        expansion: _extends({}, prevState.expansion, {
          expandedItems
        })
      }));
    }
  }, [store, params.expandedItems]);
  return {
    publicAPI: {
      setItemExpansion
    },
    instance: {
      setItemExpansion,
      applyItemExpansion,
      expandAllSiblings
    }
  };
};
var DEFAULT_EXPANDED_ITEMS = [];
useTreeViewExpansion.applyDefaultValuesToParams = ({
  params
}) => _extends({}, params, {
  defaultExpandedItems: params.defaultExpandedItems ?? DEFAULT_EXPANDED_ITEMS
});
useTreeViewExpansion.getInitialState = (params) => ({
  expansion: {
    expandedItems: params.expandedItems === void 0 ? params.defaultExpandedItems : params.expandedItems,
    expansionTrigger: getExpansionTrigger(params)
  }
});
useTreeViewExpansion.params = {
  expandedItems: true,
  defaultExpandedItems: true,
  onExpandedItemsChange: true,
  onItemExpansionToggle: true,
  expansionTrigger: true
};

// node_modules/@mui/x-tree-view/esm/internals/plugins/useTreeViewSelection/useTreeViewSelection.js
var React8 = __toESM(require_react(), 1);

// node_modules/@mui/x-tree-view/esm/internals/plugins/useTreeViewSelection/useTreeViewSelection.utils.js
var getLookupFromArray = (array) => {
  const lookup = {};
  array.forEach((itemId) => {
    lookup[itemId] = true;
  });
  return lookup;
};
var getAddedAndRemovedItems = ({
  store,
  oldModel,
  newModel
}) => {
  const newModelMap = /* @__PURE__ */ new Map();
  newModel.forEach((id) => {
    newModelMap.set(id, true);
  });
  return {
    added: newModel.filter((itemId) => !selectorIsItemSelected(store.value, itemId)),
    removed: oldModel.filter((itemId) => !newModelMap.has(itemId))
  };
};
var propagateSelection = ({
  store,
  selectionPropagation,
  newModel,
  oldModel,
  additionalItemsToPropagate
}) => {
  if (!selectionPropagation.descendants && !selectionPropagation.parents) {
    return newModel;
  }
  let shouldRegenerateModel = false;
  const newModelLookup = getLookupFromArray(newModel);
  const changes = getAddedAndRemovedItems({
    store,
    newModel,
    oldModel
  });
  additionalItemsToPropagate == null ? void 0 : additionalItemsToPropagate.forEach((itemId) => {
    if (newModelLookup[itemId]) {
      if (!changes.added.includes(itemId)) {
        changes.added.push(itemId);
      }
    } else if (!changes.removed.includes(itemId)) {
      changes.removed.push(itemId);
    }
  });
  changes.added.forEach((addedItemId) => {
    if (selectionPropagation.descendants) {
      const selectDescendants = (itemId) => {
        if (itemId !== addedItemId) {
          shouldRegenerateModel = true;
          newModelLookup[itemId] = true;
        }
        selectorItemOrderedChildrenIds(store.value, itemId).forEach(selectDescendants);
      };
      selectDescendants(addedItemId);
    }
    if (selectionPropagation.parents) {
      const checkAllDescendantsSelected = (itemId) => {
        if (!newModelLookup[itemId]) {
          return false;
        }
        const children = selectorItemOrderedChildrenIds(store.value, itemId);
        return children.every(checkAllDescendantsSelected);
      };
      const selectParents = (itemId) => {
        const parentId = selectorItemParentId(store.value, itemId);
        if (parentId == null) {
          return;
        }
        const siblings = selectorItemOrderedChildrenIds(store.value, parentId);
        if (siblings.every(checkAllDescendantsSelected)) {
          shouldRegenerateModel = true;
          newModelLookup[parentId] = true;
          selectParents(parentId);
        }
      };
      selectParents(addedItemId);
    }
  });
  changes.removed.forEach((removedItemId) => {
    if (selectionPropagation.parents) {
      let parentId = selectorItemParentId(store.value, removedItemId);
      while (parentId != null) {
        if (newModelLookup[parentId]) {
          shouldRegenerateModel = true;
          delete newModelLookup[parentId];
        }
        parentId = selectorItemParentId(store.value, parentId);
      }
    }
    if (selectionPropagation.descendants) {
      const deSelectDescendants = (itemId) => {
        if (itemId !== removedItemId) {
          shouldRegenerateModel = true;
          delete newModelLookup[itemId];
        }
        selectorItemOrderedChildrenIds(store.value, itemId).forEach(deSelectDescendants);
      };
      deSelectDescendants(removedItemId);
    }
  });
  return shouldRegenerateModel ? Object.keys(newModelLookup) : newModel;
};

// node_modules/@mui/x-internals/esm/fastObjectShallowCompare/fastObjectShallowCompare.js
var is = Object.is;
function fastObjectShallowCompare(a, b) {
  if (a === b) {
    return true;
  }
  if (!(a instanceof Object) || !(b instanceof Object)) {
    return false;
  }
  let aLength = 0;
  let bLength = 0;
  for (const key in a) {
    aLength += 1;
    if (!is(a[key], b[key])) {
      return false;
    }
    if (!(key in b)) {
      return false;
    }
  }
  for (const _ in b) {
    bLength += 1;
  }
  return aLength === bLength;
}

// node_modules/@mui/x-tree-view/esm/internals/plugins/useTreeViewSelection/useTreeViewSelection.itemPlugin.js
function selectorItemCheckboxStatus(state, itemId) {
  const isCheckboxSelectionEnabled = selectorIsCheckboxSelectionEnabled(state);
  const isSelectionEnabledForItem = selectorIsItemSelectionEnabled(state, itemId);
  if (selectorIsItemSelected(state, itemId)) {
    return {
      disabled: !isSelectionEnabledForItem,
      visible: isCheckboxSelectionEnabled,
      indeterminate: false,
      checked: true
    };
  }
  const children = selectorItemOrderedChildrenIds(state, itemId);
  if (children.length === 0) {
    return {
      disabled: !isSelectionEnabledForItem,
      visible: isCheckboxSelectionEnabled,
      indeterminate: false,
      checked: false
    };
  }
  let hasSelectedDescendant = false;
  let hasUnSelectedDescendant = false;
  const traverseDescendants = (itemToTraverseId) => {
    if (itemToTraverseId !== itemId) {
      if (selectorIsItemSelected(state, itemToTraverseId)) {
        hasSelectedDescendant = true;
      } else {
        hasUnSelectedDescendant = true;
      }
    }
    selectorItemOrderedChildrenIds(state, itemToTraverseId).forEach(traverseDescendants);
  };
  traverseDescendants(itemId);
  return {
    disabled: !isSelectionEnabledForItem,
    visible: isCheckboxSelectionEnabled,
    indeterminate: hasSelectedDescendant && hasUnSelectedDescendant,
    checked: selectorSelectionPropagationRules(state).parents ? hasSelectedDescendant && !hasUnSelectedDescendant : false
  };
}
var useTreeViewSelectionItemPlugin = ({
  props
}) => {
  const {
    itemId
  } = props;
  const {
    store
  } = useTreeViewContext();
  const checkboxStatus = useSelector(store, selectorItemCheckboxStatus, itemId, fastObjectShallowCompare);
  return {
    propsEnhancers: {
      checkbox: ({
        externalEventHandlers,
        interactions
      }) => {
        const handleChange = (event) => {
          var _a;
          (_a = externalEventHandlers.onChange) == null ? void 0 : _a.call(externalEventHandlers, event);
          if (event.defaultMuiPrevented) {
            return;
          }
          if (!selectorIsItemSelectionEnabled(store.value, itemId)) {
            return;
          }
          interactions.handleCheckboxSelection(event);
        };
        return _extends({
          tabIndex: -1,
          onChange: handleChange
        }, checkboxStatus);
      }
    }
  };
};

// node_modules/@mui/x-tree-view/esm/internals/plugins/useTreeViewSelection/useTreeViewSelection.js
var useTreeViewSelection = ({
  store,
  params
}) => {
  useAssertModelConsistency({
    componentName: "Tree View",
    propName: "selectedItems",
    controlled: params.selectedItems,
    defaultValue: params.defaultSelectedItems
  });
  const lastSelectedItem = React8.useRef(null);
  const lastSelectedRange = React8.useRef({});
  const setSelectedItems = (event, newModel, additionalItemsToPropagate) => {
    var _a;
    const oldModel = selectorSelectionModel(store.value);
    let cleanModel;
    const isMultiSelectEnabled = selectorIsMultiSelectEnabled(store.value);
    if (isMultiSelectEnabled && (params.selectionPropagation.descendants || params.selectionPropagation.parents)) {
      cleanModel = propagateSelection({
        store,
        selectionPropagation: params.selectionPropagation,
        newModel,
        oldModel,
        additionalItemsToPropagate
      });
    } else {
      cleanModel = newModel;
    }
    if (params.onItemSelectionToggle) {
      if (isMultiSelectEnabled) {
        const changes = getAddedAndRemovedItems({
          store,
          newModel: cleanModel,
          oldModel
        });
        if (params.onItemSelectionToggle) {
          changes.added.forEach((itemId) => {
            params.onItemSelectionToggle(event, itemId, true);
          });
          changes.removed.forEach((itemId) => {
            params.onItemSelectionToggle(event, itemId, false);
          });
        }
      } else if (params.onItemSelectionToggle && cleanModel !== oldModel) {
        if (oldModel != null) {
          params.onItemSelectionToggle(event, oldModel, false);
        }
        if (cleanModel != null) {
          params.onItemSelectionToggle(event, cleanModel, true);
        }
      }
    }
    if (params.selectedItems === void 0) {
      store.update((prevState) => _extends({}, prevState, {
        selection: _extends({}, prevState.selection, {
          selectedItems: cleanModel
        })
      }));
    }
    (_a = params.onSelectedItemsChange) == null ? void 0 : _a.call(params, event, cleanModel);
  };
  const setItemSelection = ({
    itemId,
    event = null,
    keepExistingSelection = false,
    shouldBeSelected
  }) => {
    if (!selectorIsSelectionEnabled(store.value)) {
      return;
    }
    let newSelected;
    const isMultiSelectEnabled = selectorIsMultiSelectEnabled(store.value);
    if (keepExistingSelection) {
      const oldSelected = selectorSelectionModelArray(store.value);
      const isSelectedBefore = selectorIsItemSelected(store.value, itemId);
      if (isSelectedBefore && (shouldBeSelected === false || shouldBeSelected == null)) {
        newSelected = oldSelected.filter((id) => id !== itemId);
      } else if (!isSelectedBefore && (shouldBeSelected === true || shouldBeSelected == null)) {
        newSelected = [itemId].concat(oldSelected);
      } else {
        newSelected = oldSelected;
      }
    } else {
      if (shouldBeSelected === false || shouldBeSelected == null && selectorIsItemSelected(store.value, itemId)) {
        newSelected = isMultiSelectEnabled ? [] : null;
      } else {
        newSelected = isMultiSelectEnabled ? [itemId] : itemId;
      }
    }
    setSelectedItems(
      event,
      newSelected,
      // If shouldBeSelected === selectorIsItemSelected(store, itemId), we still want to propagate the select.
      // This is useful when the element is in an indeterminate state.
      [itemId]
    );
    lastSelectedItem.current = itemId;
    lastSelectedRange.current = {};
  };
  const selectRange = (event, [start, end]) => {
    const isMultiSelectEnabled = selectorIsMultiSelectEnabled(store.value);
    if (!isMultiSelectEnabled) {
      return;
    }
    let newSelectedItems = selectorSelectionModelArray(store.value).slice();
    if (Object.keys(lastSelectedRange.current).length > 0) {
      newSelectedItems = newSelectedItems.filter((id) => !lastSelectedRange.current[id]);
    }
    const selectedItemsLookup = getLookupFromArray(newSelectedItems);
    const range = getNonDisabledItemsInRange(store.value, start, end);
    const itemsToAddToModel = range.filter((id) => !selectedItemsLookup[id]);
    newSelectedItems = newSelectedItems.concat(itemsToAddToModel);
    setSelectedItems(event, newSelectedItems);
    lastSelectedRange.current = getLookupFromArray(range);
  };
  const expandSelectionRange = (event, itemId) => {
    if (lastSelectedItem.current != null) {
      const [start, end] = findOrderInTremauxTree(store.value, itemId, lastSelectedItem.current);
      selectRange(event, [start, end]);
    }
  };
  const selectRangeFromStartToItem = (event, itemId) => {
    selectRange(event, [getFirstNavigableItem(store.value), itemId]);
  };
  const selectRangeFromItemToEnd = (event, itemId) => {
    selectRange(event, [itemId, getLastNavigableItem(store.value)]);
  };
  const selectAllNavigableItems = (event) => {
    const isMultiSelectEnabled = selectorIsMultiSelectEnabled(store.value);
    if (!isMultiSelectEnabled) {
      return;
    }
    const navigableItems = getAllNavigableItems(store.value);
    setSelectedItems(event, navigableItems);
    lastSelectedRange.current = getLookupFromArray(navigableItems);
  };
  const selectItemFromArrowNavigation = (event, currentItem, nextItem) => {
    const isMultiSelectEnabled = selectorIsMultiSelectEnabled(store.value);
    if (!isMultiSelectEnabled) {
      return;
    }
    let newSelectedItems = selectorSelectionModelArray(store.value).slice();
    if (Object.keys(lastSelectedRange.current).length === 0) {
      newSelectedItems.push(nextItem);
      lastSelectedRange.current = {
        [currentItem]: true,
        [nextItem]: true
      };
    } else {
      if (!lastSelectedRange.current[currentItem]) {
        lastSelectedRange.current = {};
      }
      if (lastSelectedRange.current[nextItem]) {
        newSelectedItems = newSelectedItems.filter((id) => id !== currentItem);
        delete lastSelectedRange.current[currentItem];
      } else {
        newSelectedItems.push(nextItem);
        lastSelectedRange.current[nextItem] = true;
      }
    }
    setSelectedItems(event, newSelectedItems);
  };
  useEnhancedEffect_default(() => {
    store.update((prevState) => _extends({}, prevState, {
      selection: {
        selectedItems: params.selectedItems === void 0 ? prevState.selection.selectedItems : params.selectedItems,
        isEnabled: !params.disableSelection,
        isMultiSelectEnabled: params.multiSelect,
        isCheckboxSelectionEnabled: params.checkboxSelection,
        selectionPropagation: {
          descendants: params.selectionPropagation.descendants,
          parents: params.selectionPropagation.parents
        }
      }
    }));
  }, [store, params.selectedItems, params.multiSelect, params.checkboxSelection, params.disableSelection, params.selectionPropagation.descendants, params.selectionPropagation.parents]);
  return {
    getRootProps: () => ({
      "aria-multiselectable": params.multiSelect
    }),
    publicAPI: {
      setItemSelection
    },
    instance: {
      setItemSelection,
      selectAllNavigableItems,
      expandSelectionRange,
      selectRangeFromStartToItem,
      selectRangeFromItemToEnd,
      selectItemFromArrowNavigation
    }
  };
};
useTreeViewSelection.itemPlugin = useTreeViewSelectionItemPlugin;
var DEFAULT_SELECTED_ITEMS = [];
var EMPTY_SELECTION_PROPAGATION = {};
useTreeViewSelection.applyDefaultValuesToParams = ({
  params
}) => _extends({}, params, {
  disableSelection: params.disableSelection ?? false,
  multiSelect: params.multiSelect ?? false,
  checkboxSelection: params.checkboxSelection ?? false,
  defaultSelectedItems: params.defaultSelectedItems ?? (params.multiSelect ? DEFAULT_SELECTED_ITEMS : null),
  selectionPropagation: params.selectionPropagation ?? EMPTY_SELECTION_PROPAGATION
});
useTreeViewSelection.getInitialState = (params) => ({
  selection: {
    selectedItems: params.selectedItems === void 0 ? params.defaultSelectedItems : params.selectedItems,
    isEnabled: !params.disableSelection,
    isMultiSelectEnabled: params.multiSelect,
    isCheckboxSelectionEnabled: params.checkboxSelection,
    selectionPropagation: params.selectionPropagation
  }
});
useTreeViewSelection.params = {
  disableSelection: true,
  multiSelect: true,
  checkboxSelection: true,
  defaultSelectedItems: true,
  selectedItems: true,
  onSelectedItemsChange: true,
  onItemSelectionToggle: true,
  selectionPropagation: true
};

// node_modules/@mui/x-tree-view/esm/internals/hooks/useInstanceEventHandler.js
var React9 = __toESM(require_react(), 1);

// node_modules/@mui/x-tree-view/esm/internals/utils/cleanupTracking/TimerBasedCleanupTracking.js
var CLEANUP_TIMER_LOOP_MILLIS = 1e3;
var TimerBasedCleanupTracking = class {
  constructor(timeout = CLEANUP_TIMER_LOOP_MILLIS) {
    this.timeouts = /* @__PURE__ */ new Map();
    this.cleanupTimeout = CLEANUP_TIMER_LOOP_MILLIS;
    this.cleanupTimeout = timeout;
  }
  register(object, unsubscribe, unregisterToken) {
    if (!this.timeouts) {
      this.timeouts = /* @__PURE__ */ new Map();
    }
    const timeout = setTimeout(() => {
      if (typeof unsubscribe === "function") {
        unsubscribe();
      }
      this.timeouts.delete(unregisterToken.cleanupToken);
    }, this.cleanupTimeout);
    this.timeouts.set(unregisterToken.cleanupToken, timeout);
  }
  unregister(unregisterToken) {
    const timeout = this.timeouts.get(unregisterToken.cleanupToken);
    if (timeout) {
      this.timeouts.delete(unregisterToken.cleanupToken);
      clearTimeout(timeout);
    }
  }
  reset() {
    if (this.timeouts) {
      this.timeouts.forEach((value, key) => {
        this.unregister({
          cleanupToken: key
        });
      });
      this.timeouts = void 0;
    }
  }
};

// node_modules/@mui/x-tree-view/esm/internals/utils/cleanupTracking/FinalizationRegistryBasedCleanupTracking.js
var FinalizationRegistryBasedCleanupTracking = class {
  constructor() {
    this.registry = new FinalizationRegistry((unsubscribe) => {
      if (typeof unsubscribe === "function") {
        unsubscribe();
      }
    });
  }
  register(object, unsubscribe, unregisterToken) {
    this.registry.register(object, unsubscribe, unregisterToken);
  }
  unregister(unregisterToken) {
    this.registry.unregister(unregisterToken);
  }
  // eslint-disable-next-line class-methods-use-this
  reset() {
  }
};

// node_modules/@mui/x-tree-view/esm/internals/hooks/useInstanceEventHandler.js
var ObjectToBeRetainedByReact = class {
};
function createUseInstanceEventHandler(registryContainer2) {
  let cleanupTokensCounter = 0;
  return function useInstanceEventHandler2(instance, eventName, handler) {
    if (registryContainer2.registry === null) {
      registryContainer2.registry = typeof FinalizationRegistry !== "undefined" ? new FinalizationRegistryBasedCleanupTracking() : new TimerBasedCleanupTracking();
    }
    const [objectRetainedByReact] = React9.useState(new ObjectToBeRetainedByReact());
    const subscription = React9.useRef(null);
    const handlerRef = React9.useRef(void 0);
    handlerRef.current = handler;
    const cleanupTokenRef = React9.useRef(null);
    if (!subscription.current && handlerRef.current) {
      const enhancedHandler = (params, event) => {
        var _a;
        if (!event.defaultMuiPrevented) {
          (_a = handlerRef.current) == null ? void 0 : _a.call(handlerRef, params, event);
        }
      };
      subscription.current = instance.$$subscribeEvent(eventName, enhancedHandler);
      cleanupTokensCounter += 1;
      cleanupTokenRef.current = {
        cleanupToken: cleanupTokensCounter
      };
      registryContainer2.registry.register(
        objectRetainedByReact,
        // The callback below will be called once this reference stops being retained
        () => {
          var _a;
          (_a = subscription.current) == null ? void 0 : _a.call(subscription);
          subscription.current = null;
          cleanupTokenRef.current = null;
        },
        cleanupTokenRef.current
      );
    } else if (!handlerRef.current && subscription.current) {
      subscription.current();
      subscription.current = null;
      if (cleanupTokenRef.current) {
        registryContainer2.registry.unregister(cleanupTokenRef.current);
        cleanupTokenRef.current = null;
      }
    }
    React9.useEffect(() => {
      if (!subscription.current && handlerRef.current) {
        const enhancedHandler = (params, event) => {
          var _a;
          if (!event.defaultMuiPrevented) {
            (_a = handlerRef.current) == null ? void 0 : _a.call(handlerRef, params, event);
          }
        };
        subscription.current = instance.$$subscribeEvent(eventName, enhancedHandler);
      }
      if (cleanupTokenRef.current && registryContainer2.registry) {
        registryContainer2.registry.unregister(cleanupTokenRef.current);
        cleanupTokenRef.current = null;
      }
      return () => {
        var _a;
        (_a = subscription.current) == null ? void 0 : _a.call(subscription);
        subscription.current = null;
      };
    }, [instance, eventName]);
  };
}
var registryContainer = {
  registry: null
};
var useInstanceEventHandler = createUseInstanceEventHandler(registryContainer);

// node_modules/@mui/x-tree-view/esm/internals/plugins/useTreeViewFocus/useTreeViewFocus.js
var useTreeViewFocus = ({
  instance,
  params,
  store
}) => {
  const setFocusedItemId = useEventCallback_default((itemId) => {
    store.update((prevState) => {
      const focusedItemId = selectorFocusedItemId(prevState);
      if (focusedItemId === itemId) {
        return prevState;
      }
      return _extends({}, prevState, {
        focus: _extends({}, prevState.focus, {
          focusedItemId: itemId
        })
      });
    });
  });
  const isItemVisible = (itemId) => {
    const itemMeta = selectorItemMeta(store.value, itemId);
    return itemMeta && (itemMeta.parentId == null || selectorIsItemExpanded(store.value, itemMeta.parentId));
  };
  const innerFocusItem = (event, itemId) => {
    const itemElement = instance.getItemDOMElement(itemId);
    if (itemElement) {
      itemElement.focus();
    }
    setFocusedItemId(itemId);
    if (params.onItemFocus) {
      params.onItemFocus(event, itemId);
    }
  };
  const focusItem = useEventCallback_default((event, itemId) => {
    if (isItemVisible(itemId)) {
      innerFocusItem(event, itemId);
    }
  });
  const removeFocusedItem = useEventCallback_default(() => {
    const focusedItemId = selectorFocusedItemId(store.value);
    if (focusedItemId == null) {
      return;
    }
    const itemMeta = selectorItemMeta(store.value, focusedItemId);
    if (itemMeta) {
      const itemElement = instance.getItemDOMElement(focusedItemId);
      if (itemElement) {
        itemElement.blur();
      }
    }
    setFocusedItemId(null);
  });
  useInstanceEventHandler(instance, "removeItem", ({
    id
  }) => {
    const focusedItemId = selectorFocusedItemId(store.value);
    const defaultFocusableItemId = selectorDefaultFocusableItemId(store.value);
    if (focusedItemId === id && defaultFocusableItemId != null) {
      innerFocusItem(null, defaultFocusableItemId);
    }
  });
  const createRootHandleFocus = (otherHandlers) => (event) => {
    var _a;
    (_a = otherHandlers.onFocus) == null ? void 0 : _a.call(otherHandlers, event);
    if (event.defaultMuiPrevented) {
      return;
    }
    const defaultFocusableItemId = selectorDefaultFocusableItemId(store.value);
    if (event.target === event.currentTarget && defaultFocusableItemId != null) {
      innerFocusItem(event, defaultFocusableItemId);
    }
  };
  const createRootHandleBlur = (otherHandlers) => (event) => {
    var _a;
    (_a = otherHandlers.onBlur) == null ? void 0 : _a.call(otherHandlers, event);
    if (event.defaultMuiPrevented) {
      return;
    }
    setFocusedItemId(null);
  };
  return {
    getRootProps: (otherHandlers) => ({
      onFocus: createRootHandleFocus(otherHandlers),
      onBlur: createRootHandleBlur(otherHandlers)
    }),
    publicAPI: {
      focusItem
    },
    instance: {
      focusItem,
      removeFocusedItem
    }
  };
};
useTreeViewFocus.getInitialState = () => ({
  focus: {
    focusedItemId: null
  }
});
useTreeViewFocus.params = {
  onItemFocus: true
};

// node_modules/@mui/x-tree-view/esm/internals/plugins/useTreeViewKeyboardNavigation/useTreeViewKeyboardNavigation.js
var React10 = __toESM(require_react(), 1);
function isPrintableKey(string) {
  return !!string && string.length === 1 && !!string.match(/\S/);
}
var useTreeViewKeyboardNavigation = ({
  instance,
  store,
  params
}) => {
  const isRtl = useRtl();
  const firstCharMap = React10.useRef({});
  const updateFirstCharMap = useEventCallback_default((callback) => {
    firstCharMap.current = callback(firstCharMap.current);
  });
  const itemMetaLookup = useSelector(store, selectorItemMetaLookup);
  React10.useEffect(() => {
    if (instance.areItemUpdatesPrevented()) {
      return;
    }
    const newFirstCharMap = {};
    const processItem = (item) => {
      newFirstCharMap[item.id] = item.label.substring(0, 1).toLowerCase();
    };
    Object.values(itemMetaLookup).forEach(processItem);
    firstCharMap.current = newFirstCharMap;
  }, [itemMetaLookup, params.getItemId, instance]);
  const getFirstMatchingItem = (itemId, query) => {
    const cleanQuery = query.toLowerCase();
    const getNextItem = (itemIdToCheck) => {
      const nextItemId = getNextNavigableItem(store.value, itemIdToCheck);
      if (nextItemId === null) {
        return getFirstNavigableItem(store.value);
      }
      return nextItemId;
    };
    let matchingItemId = null;
    let currentItemId = getNextItem(itemId);
    const checkedItems = {};
    while (matchingItemId == null && !checkedItems[currentItemId]) {
      if (firstCharMap.current[currentItemId] === cleanQuery) {
        matchingItemId = currentItemId;
      } else {
        checkedItems[currentItemId] = true;
        currentItemId = getNextItem(currentItemId);
      }
    }
    return matchingItemId;
  };
  const canToggleItemSelection = (itemId) => selectorIsSelectionEnabled(store.value) && !selectorIsItemDisabled(store.value, itemId);
  const canToggleItemExpansion = (itemId) => {
    return !selectorIsItemDisabled(store.value, itemId) && selectorIsItemExpandable(store.value, itemId);
  };
  const handleItemKeyDown = async (event, itemId) => {
    if (event.defaultMuiPrevented) {
      return;
    }
    if (event.altKey || isTargetInDescendants(event.target, event.currentTarget)) {
      return;
    }
    const ctrlPressed = event.ctrlKey || event.metaKey;
    const key = event.key;
    const isMultiSelectEnabled = selectorIsMultiSelectEnabled(store.value);
    switch (true) {
      // Select the item when pressing "Space"
      case (key === " " && canToggleItemSelection(itemId)): {
        event.preventDefault();
        if (isMultiSelectEnabled && event.shiftKey) {
          instance.expandSelectionRange(event, itemId);
        } else {
          instance.setItemSelection({
            event,
            itemId,
            keepExistingSelection: isMultiSelectEnabled,
            shouldBeSelected: void 0
          });
        }
        break;
      }
      // If the focused item has children, we expand it.
      // If the focused item has no children, we select it.
      case key === "Enter": {
        if (hasPlugin(instance, useTreeViewLabel) && selectorIsItemEditable(store.value, itemId) && !selectorIsItemBeingEdited(store.value, itemId)) {
          instance.setEditedItemId(itemId);
        } else if (canToggleItemExpansion(itemId)) {
          instance.setItemExpansion({
            event,
            itemId
          });
          event.preventDefault();
        } else if (canToggleItemSelection(itemId)) {
          if (isMultiSelectEnabled) {
            event.preventDefault();
            instance.setItemSelection({
              event,
              itemId,
              keepExistingSelection: true
            });
          } else if (!selectorIsItemSelected(store.value, itemId)) {
            instance.setItemSelection({
              event,
              itemId
            });
            event.preventDefault();
          }
        }
        break;
      }
      // Focus the next focusable item
      case key === "ArrowDown": {
        const nextItem = getNextNavigableItem(store.value, itemId);
        if (nextItem) {
          event.preventDefault();
          instance.focusItem(event, nextItem);
          if (isMultiSelectEnabled && event.shiftKey && canToggleItemSelection(nextItem)) {
            instance.selectItemFromArrowNavigation(event, itemId, nextItem);
          }
        }
        break;
      }
      // Focuses the previous focusable item
      case key === "ArrowUp": {
        const previousItem = getPreviousNavigableItem(store.value, itemId);
        if (previousItem) {
          event.preventDefault();
          instance.focusItem(event, previousItem);
          if (isMultiSelectEnabled && event.shiftKey && canToggleItemSelection(previousItem)) {
            instance.selectItemFromArrowNavigation(event, itemId, previousItem);
          }
        }
        break;
      }
      // If the focused item is expanded, we move the focus to its first child
      // If the focused item is collapsed and has children, we expand it
      case (key === "ArrowRight" && !isRtl || key === "ArrowLeft" && isRtl): {
        if (ctrlPressed) {
          return;
        }
        if (selectorIsItemExpanded(store.value, itemId)) {
          const nextItemId = getNextNavigableItem(store.value, itemId);
          if (nextItemId) {
            instance.focusItem(event, nextItemId);
            event.preventDefault();
          }
        } else if (canToggleItemExpansion(itemId)) {
          instance.setItemExpansion({
            event,
            itemId
          });
          event.preventDefault();
        }
        break;
      }
      // If the focused item is expanded, we collapse it
      // If the focused item is collapsed and has a parent, we move the focus to this parent
      case (key === "ArrowLeft" && !isRtl || key === "ArrowRight" && isRtl): {
        if (ctrlPressed) {
          return;
        }
        if (canToggleItemExpansion(itemId) && selectorIsItemExpanded(store.value, itemId)) {
          instance.setItemExpansion({
            event,
            itemId
          });
          event.preventDefault();
        } else {
          const parent = selectorItemParentId(store.value, itemId);
          if (parent) {
            instance.focusItem(event, parent);
            event.preventDefault();
          }
        }
        break;
      }
      // Focuses the first item in the tree
      case key === "Home": {
        if (canToggleItemSelection(itemId) && isMultiSelectEnabled && ctrlPressed && event.shiftKey) {
          instance.selectRangeFromStartToItem(event, itemId);
        } else {
          instance.focusItem(event, getFirstNavigableItem(store.value));
        }
        event.preventDefault();
        break;
      }
      // Focuses the last item in the tree
      case key === "End": {
        if (canToggleItemSelection(itemId) && isMultiSelectEnabled && ctrlPressed && event.shiftKey) {
          instance.selectRangeFromItemToEnd(event, itemId);
        } else {
          instance.focusItem(event, getLastNavigableItem(store.value));
        }
        event.preventDefault();
        break;
      }
      // Expand all siblings that are at the same level as the focused item
      case key === "*": {
        instance.expandAllSiblings(event, itemId);
        event.preventDefault();
        break;
      }
      // Multi select behavior when pressing Ctrl + a
      // Selects all the items
      case (String.fromCharCode(event.keyCode) === "A" && ctrlPressed && isMultiSelectEnabled && selectorIsSelectionEnabled(store.value)): {
        instance.selectAllNavigableItems(event);
        event.preventDefault();
        break;
      }
      // Type-ahead
      // TODO: Support typing multiple characters
      case (!ctrlPressed && !event.shiftKey && isPrintableKey(key)): {
        const matchingItem = getFirstMatchingItem(itemId, key);
        if (matchingItem != null) {
          instance.focusItem(event, matchingItem);
          event.preventDefault();
        }
        break;
      }
    }
  };
  return {
    instance: {
      updateFirstCharMap,
      handleItemKeyDown
    }
  };
};
useTreeViewKeyboardNavigation.params = {};

// node_modules/@mui/x-tree-view/esm/internals/plugins/useTreeViewJSXItems/useTreeViewJSXItems.js
var React12 = __toESM(require_react(), 1);

// node_modules/@mui/x-tree-view/esm/internals/TreeViewProvider/TreeViewChildrenItemProvider.js
var React11 = __toESM(require_react(), 1);
var import_prop_types = __toESM(require_prop_types(), 1);

// node_modules/@mui/x-tree-view/esm/internals/utils/utils.js
function escapeOperandAttributeSelector(operand) {
  return operand.replace(/["\\]/g, "\\$&");
}

// node_modules/@mui/x-tree-view/esm/internals/TreeViewProvider/TreeViewChildrenItemProvider.js
var import_jsx_runtime2 = __toESM(require_jsx_runtime(), 1);
var TreeViewChildrenItemContext = React11.createContext(null);
if (true) {
  TreeViewChildrenItemContext.displayName = "TreeViewChildrenItemContext";
}
function TreeViewChildrenItemProvider(props) {
  const {
    children,
    itemId = null,
    idAttribute
  } = props;
  const {
    instance,
    store,
    rootRef
  } = useTreeViewContext();
  const childrenIdAttrToIdRef = React11.useRef(/* @__PURE__ */ new Map());
  React11.useEffect(() => {
    if (!rootRef.current) {
      return;
    }
    const previousChildrenIds = selectorItemOrderedChildrenIds(store.value, itemId ?? null) ?? [];
    const escapedIdAttr = escapeOperandAttributeSelector(idAttribute ?? rootRef.current.id);
    const childrenElements = rootRef.current.querySelectorAll(`${itemId == null ? "" : `*[id="${escapedIdAttr}"] `}[role="treeitem"]:not(*[id="${escapedIdAttr}"] [role="treeitem"] [role="treeitem"])`);
    const childrenIds = Array.from(childrenElements).map((child) => childrenIdAttrToIdRef.current.get(child.id));
    const hasChanged = childrenIds.length !== previousChildrenIds.length || childrenIds.some((childId, index) => childId !== previousChildrenIds[index]);
    if (hasChanged) {
      instance.setJSXItemsOrderedChildrenIds(itemId ?? null, childrenIds);
    }
  });
  const value = React11.useMemo(() => ({
    registerChild: (childIdAttribute, childItemId) => childrenIdAttrToIdRef.current.set(childIdAttribute, childItemId),
    unregisterChild: (childIdAttribute) => childrenIdAttrToIdRef.current.delete(childIdAttribute),
    parentId: itemId
  }), [itemId]);
  return (0, import_jsx_runtime2.jsx)(TreeViewChildrenItemContext.Provider, {
    value,
    children
  });
}
true ? TreeViewChildrenItemProvider.propTypes = {
  children: import_prop_types.default.node,
  id: import_prop_types.default.string
} : void 0;

// node_modules/@mui/x-tree-view/esm/internals/plugins/useTreeViewJSXItems/useTreeViewJSXItems.js
var import_jsx_runtime3 = __toESM(require_jsx_runtime(), 1);
var useTreeViewJSXItems = ({
  instance,
  store
}) => {
  instance.preventItemUpdates();
  const insertJSXItem = useEventCallback_default((item) => {
    store.update((prevState) => {
      if (prevState.items.itemMetaLookup[item.id] != null) {
        throw new Error(["MUI X: The Tree View component requires all items to have a unique `id` property.", "Alternatively, you can use the `getItemId` prop to specify a custom id for each item.", `Two items were provided with the same id in the \`items\` prop: "${item.id}"`].join("\n"));
      }
      return _extends({}, prevState, {
        items: _extends({}, prevState.items, {
          itemMetaLookup: _extends({}, prevState.items.itemMetaLookup, {
            [item.id]: item
          }),
          // For Simple Tree View, we don't have a proper `item` object, so we create a very basic one.
          itemModelLookup: _extends({}, prevState.items.itemModelLookup, {
            [item.id]: {
              id: item.id,
              label: item.label ?? ""
            }
          })
        })
      });
    });
    return () => {
      store.update((prevState) => {
        const newItemMetaLookup = _extends({}, prevState.items.itemMetaLookup);
        const newItemModelLookup = _extends({}, prevState.items.itemModelLookup);
        delete newItemMetaLookup[item.id];
        delete newItemModelLookup[item.id];
        return _extends({}, prevState, {
          items: _extends({}, prevState.items, {
            itemMetaLookup: newItemMetaLookup,
            itemModelLookup: newItemModelLookup
          })
        });
      });
      publishTreeViewEvent(instance, "removeItem", {
        id: item.id
      });
    };
  });
  const setJSXItemsOrderedChildrenIds = (parentId, orderedChildrenIds) => {
    const parentIdWithDefault = parentId ?? TREE_VIEW_ROOT_PARENT_ID;
    store.update((prevState) => _extends({}, prevState, {
      items: _extends({}, prevState.items, {
        itemOrderedChildrenIdsLookup: _extends({}, prevState.items.itemOrderedChildrenIdsLookup, {
          [parentIdWithDefault]: orderedChildrenIds
        }),
        itemChildrenIndexesLookup: _extends({}, prevState.items.itemChildrenIndexesLookup, {
          [parentIdWithDefault]: buildSiblingIndexes(orderedChildrenIds)
        })
      })
    }));
  };
  const mapFirstCharFromJSX = useEventCallback_default((itemId, firstChar) => {
    instance.updateFirstCharMap((firstCharMap) => {
      firstCharMap[itemId] = firstChar;
      return firstCharMap;
    });
    return () => {
      instance.updateFirstCharMap((firstCharMap) => {
        const newMap = _extends({}, firstCharMap);
        delete newMap[itemId];
        return newMap;
      });
    };
  });
  return {
    instance: {
      insertJSXItem,
      setJSXItemsOrderedChildrenIds,
      mapFirstCharFromJSX
    }
  };
};
var useTreeViewJSXItemsItemPlugin = ({
  props,
  rootRef,
  contentRef
}) => {
  const {
    instance,
    store
  } = useTreeViewContext();
  const {
    children,
    disabled = false,
    label,
    itemId,
    id
  } = props;
  const parentContext = React12.useContext(TreeViewChildrenItemContext);
  if (parentContext == null) {
    throw new Error(["MUI X: Could not find the Tree View Children Item context.", "It looks like you rendered your component outside of a SimpleTreeView parent component.", "This can also happen if you are bundling multiple versions of the Tree View."].join("\n"));
  }
  const {
    registerChild,
    unregisterChild,
    parentId
  } = parentContext;
  const expandable = itemHasChildren(children);
  const pluginContentRef = React12.useRef(null);
  const handleContentRef = useForkRef(pluginContentRef, contentRef);
  const treeId = useSelector(store, selectorTreeViewId);
  useEnhancedEffect_default(() => {
    const idAttribute = generateTreeItemIdAttribute({
      itemId,
      treeId,
      id
    });
    registerChild(idAttribute, itemId);
    return () => {
      unregisterChild(idAttribute);
      unregisterChild(idAttribute);
    };
  }, [store, instance, registerChild, unregisterChild, itemId, id, treeId]);
  useEnhancedEffect_default(() => {
    return instance.insertJSXItem({
      id: itemId,
      idAttribute: id,
      parentId,
      expandable,
      disabled
    });
  }, [instance, parentId, itemId, expandable, disabled, id]);
  React12.useEffect(() => {
    var _a;
    if (label) {
      return instance.mapFirstCharFromJSX(itemId, (((_a = pluginContentRef.current) == null ? void 0 : _a.textContent) ?? "").substring(0, 1).toLowerCase());
    }
    return void 0;
  }, [instance, itemId, label]);
  return {
    contentRef: handleContentRef,
    rootRef
  };
};
useTreeViewJSXItems.itemPlugin = useTreeViewJSXItemsItemPlugin;
useTreeViewJSXItems.wrapItem = ({
  children,
  itemId,
  idAttribute
}) => {
  const depthContext = React12.useContext(TreeViewItemDepthContext);
  return (0, import_jsx_runtime3.jsx)(TreeViewChildrenItemProvider, {
    itemId,
    idAttribute,
    children: (0, import_jsx_runtime3.jsx)(TreeViewItemDepthContext.Provider, {
      value: depthContext + 1,
      children
    })
  });
};
useTreeViewJSXItems.wrapRoot = ({
  children
}) => (0, import_jsx_runtime3.jsx)(TreeViewChildrenItemProvider, {
  itemId: null,
  idAttribute: null,
  children: (0, import_jsx_runtime3.jsx)(TreeViewItemDepthContext.Provider, {
    value: 0,
    children
  })
});
useTreeViewJSXItems.params = {};

// node_modules/@mui/x-tree-view/esm/SimpleTreeView/SimpleTreeView.plugins.js
var SIMPLE_TREE_VIEW_PLUGINS = [useTreeViewItems, useTreeViewExpansion, useTreeViewSelection, useTreeViewFocus, useTreeViewKeyboardNavigation, useTreeViewJSXItems];

// node_modules/@mui/x-tree-view/esm/SimpleTreeView/SimpleTreeView.js
var import_jsx_runtime4 = __toESM(require_jsx_runtime(), 1);
var _excluded2 = ["slots", "slotProps"];
var useThemeProps = createUseThemeProps("MuiSimpleTreeView");
var useUtilityClasses = (ownerState) => {
  const {
    classes
  } = ownerState;
  return React13.useMemo(() => {
    const slots = {
      root: ["root"],
      item: ["item"],
      itemContent: ["itemContent"],
      itemGroupTransition: ["itemGroupTransition"],
      itemIconContainer: ["itemIconContainer"],
      itemLabel: ["itemLabel"],
      // itemLabelInput: ['itemLabelInput'], => feature not available on this component
      itemCheckbox: ["itemCheckbox"]
      // itemDragAndDropOverlay: ['itemDragAndDropOverlay'], => feature not available on this component
      // itemErrorIcon: ['itemErrorIcon'], => feature not available on this component
    };
    return composeClasses(slots, getSimpleTreeViewUtilityClass, classes);
  }, [classes]);
};
var SimpleTreeViewRoot = styled_default("ul", {
  name: "MuiSimpleTreeView",
  slot: "Root"
})({
  padding: 0,
  margin: 0,
  listStyle: "none",
  outline: 0,
  position: "relative"
});
var EMPTY_ITEMS = [];
var SimpleTreeView = React13.forwardRef(function SimpleTreeView2(inProps, ref) {
  const props = useThemeProps({
    props: inProps,
    name: "MuiSimpleTreeView"
  });
  const {
    slots,
    slotProps
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded2);
  if (true) {
    if (props.items != null) {
      warnOnce(["MUI X: The Simple Tree View component does not support the `items` prop.", "If you want to add items, you need to pass them as JSX children.", "Check the documentation for more details: https://mui.com/x/react-tree-view/simple-tree-view/items/."]);
    }
  }
  const {
    getRootProps,
    contextValue
  } = useTreeView({
    plugins: SIMPLE_TREE_VIEW_PLUGINS,
    rootRef: ref,
    props: _extends({}, other, {
      items: EMPTY_ITEMS
    })
  });
  const classes = useUtilityClasses(props);
  const Root = (slots == null ? void 0 : slots.root) ?? SimpleTreeViewRoot;
  const rootProps = useSlotProps_default({
    elementType: Root,
    externalSlotProps: slotProps == null ? void 0 : slotProps.root,
    className: classes.root,
    getSlotProps: getRootProps,
    ownerState: props
  });
  return (0, import_jsx_runtime4.jsx)(TreeViewProvider, {
    contextValue,
    classes,
    slots,
    slotProps,
    children: (0, import_jsx_runtime4.jsx)(Root, _extends({}, rootProps))
  });
});
true ? SimpleTreeView.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "pnpm proptypes"  |
  // ----------------------------------------------------------------------
  /**
   * The ref object that allows Tree View manipulation. Can be instantiated with `useTreeViewApiRef()`.
   */
  apiRef: import_prop_types2.default.shape({
    current: import_prop_types2.default.shape({
      focusItem: import_prop_types2.default.func.isRequired,
      getItem: import_prop_types2.default.func.isRequired,
      getItemDOMElement: import_prop_types2.default.func.isRequired,
      getItemOrderedChildrenIds: import_prop_types2.default.func.isRequired,
      getItemTree: import_prop_types2.default.func.isRequired,
      getParentId: import_prop_types2.default.func.isRequired,
      setIsItemDisabled: import_prop_types2.default.func.isRequired,
      setItemExpansion: import_prop_types2.default.func.isRequired,
      setItemSelection: import_prop_types2.default.func.isRequired
    })
  }),
  /**
   * If `true`, the Tree View renders a checkbox at the left of its label that allows selecting it.
   * @default false
   */
  checkboxSelection: import_prop_types2.default.bool,
  /**
   * The content of the component.
   */
  children: import_prop_types2.default.node,
  /**
   * Override or extend the styles applied to the component.
   */
  classes: import_prop_types2.default.object,
  className: import_prop_types2.default.string,
  /**
   * Expanded item ids.
   * Used when the item's expansion is not controlled.
   * @default []
   */
  defaultExpandedItems: import_prop_types2.default.arrayOf(import_prop_types2.default.string),
  /**
   * Selected item ids. (Uncontrolled)
   * When `multiSelect` is true this takes an array of strings; when false (default) a string.
   * @default []
   */
  defaultSelectedItems: import_prop_types2.default.any,
  /**
   * If `true`, will allow focus on disabled items.
   * @default false
   */
  disabledItemsFocusable: import_prop_types2.default.bool,
  /**
   * If `true` selection is disabled.
   * @default false
   */
  disableSelection: import_prop_types2.default.bool,
  /**
   * Expanded item ids.
   * Used when the item's expansion is controlled.
   */
  expandedItems: import_prop_types2.default.arrayOf(import_prop_types2.default.string),
  /**
   * The slot that triggers the item's expansion when clicked.
   * @default 'content'
   */
  expansionTrigger: import_prop_types2.default.oneOf(["content", "iconContainer"]),
  /**
   * This prop is used to help implement the accessibility logic.
   * If you don't provide this prop. It falls back to a randomly generated id.
   */
  id: import_prop_types2.default.string,
  /**
   * Horizontal indentation between an item and its children.
   * Examples: 24, "24px", "2rem", "2em".
   * @default 12px
   */
  itemChildrenIndentation: import_prop_types2.default.oneOfType([import_prop_types2.default.number, import_prop_types2.default.string]),
  /**
   * If `true`, `ctrl` and `shift` will trigger multiselect.
   * @default false
   */
  multiSelect: import_prop_types2.default.bool,
  /**
   * Callback fired when Tree Items are expanded/collapsed.
   * @param {React.SyntheticEvent} event The DOM event that triggered the change. Can be null when the change is caused by the `publicAPI.setItemExpansion()` method.
   * @param {array} itemIds The ids of the expanded items.
   */
  onExpandedItemsChange: import_prop_types2.default.func,
  /**
   * Callback fired when the `content` slot of a given Tree Item is clicked.
   * @param {React.MouseEvent} event The DOM event that triggered the change.
   * @param {string} itemId The id of the focused item.
   */
  onItemClick: import_prop_types2.default.func,
  /**
   * Callback fired when a Tree Item is expanded or collapsed.
   * @param {React.SyntheticEvent | null} event The DOM event that triggered the change. Can be null when the change is caused by the `publicAPI.setItemExpansion()` method.
   * @param {array} itemId The itemId of the modified item.
   * @param {array} isExpanded `true` if the item has just been expanded, `false` if it has just been collapsed.
   */
  onItemExpansionToggle: import_prop_types2.default.func,
  /**
   * Callback fired when a given Tree Item is focused.
   * @param {React.SyntheticEvent | null} event The DOM event that triggered the change. **Warning**: This is a generic event not a focus event.
   * @param {string} itemId The id of the focused item.
   */
  onItemFocus: import_prop_types2.default.func,
  /**
   * Callback fired when a Tree Item is selected or deselected.
   * @param {React.SyntheticEvent} event The DOM event that triggered the change. Can be null when the change is caused by the `publicAPI.setItemSelection()` method.
   * @param {array} itemId The itemId of the modified item.
   * @param {array} isSelected `true` if the item has just been selected, `false` if it has just been deselected.
   */
  onItemSelectionToggle: import_prop_types2.default.func,
  /**
   * Callback fired when Tree Items are selected/deselected.
   * @param {React.SyntheticEvent} event The DOM event that triggered the change. Can be null when the change is caused by the `publicAPI.setItemSelection()` method.
   * @param {string[] | string} itemIds The ids of the selected items.
   * When `multiSelect` is `true`, this is an array of strings; when false (default) a string.
   */
  onSelectedItemsChange: import_prop_types2.default.func,
  /**
   * Selected item ids. (Controlled)
   * When `multiSelect` is true this takes an array of strings; when false (default) a string.
   */
  selectedItems: import_prop_types2.default.any,
  /**
   * When `selectionPropagation.descendants` is set to `true`.
   *
   * - Selecting a parent selects all its descendants automatically.
   * - Deselecting a parent deselects all its descendants automatically.
   *
   * When `selectionPropagation.parents` is set to `true`.
   *
   * - Selecting all the descendants of a parent selects the parent automatically.
   * - Deselecting a descendant of a selected parent deselects the parent automatically.
   *
   * Only works when `multiSelect` is `true`.
   * On the <SimpleTreeView />, only the expanded items are considered (since the collapsed item are not passed to the Tree View component at all)
   *
   * @default { parents: false, descendants: false }
   */
  selectionPropagation: import_prop_types2.default.shape({
    descendants: import_prop_types2.default.bool,
    parents: import_prop_types2.default.bool
  }),
  /**
   * The props used for each component slot.
   */
  slotProps: import_prop_types2.default.object,
  /**
   * Overridable component slots.
   */
  slots: import_prop_types2.default.object,
  /**
   * The system prop that allows defining system overrides as well as additional CSS styles.
   */
  sx: import_prop_types2.default.oneOfType([import_prop_types2.default.arrayOf(import_prop_types2.default.oneOfType([import_prop_types2.default.func, import_prop_types2.default.object, import_prop_types2.default.bool])), import_prop_types2.default.func, import_prop_types2.default.object])
} : void 0;
export {
  SimpleTreeView,
  SimpleTreeViewRoot,
  getSimpleTreeViewUtilityClass,
  simpleTreeViewClasses
};
//# sourceMappingURL=@mui_x-tree-view_SimpleTreeView.js.map
